{"version":3,"file":"index.js","sources":["../src/tree/AbstractTree.ts","../src/tree/TreeNode.ts","../src/tree/BinarySearchTree.ts","../src/tree/BinaryTree.ts","../src/exceptions/ArgumentNullException.ts","../src/exceptions/ArgumentOutOfRangeException.ts","../src/exceptions/ArgumentException.ts","../src/exceptions/InvalidOperationException.ts","../src/list/List.ts","../src/set/TreeSet.ts"],"sourcesContent":["import { ITree, TraverseType } from \"./ITree\";\r\nimport { INode } from \"./INode\";\r\n\r\nexport abstract class AbstractTree<T> implements ITree<T> {\r\n    protected comparator: Function = null;\r\n    protected root: INode<T>;\r\n    protected constructor(comparator: Function) {\r\n        this.comparator = comparator;\r\n    }\r\n    public clear(): void {\r\n        this.root = null;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.containsRecursive(this.root, item);\r\n    }\r\n    private containsRecursive(root: INode<T>, item: T): boolean {\r\n        if (root == null) return false;\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        return this.comparator(item, root.getData()) < 0\r\n            ? this.containsRecursive(root.getLeft(), item)\r\n            : this.containsRecursive(root.getRight(), item);\r\n    }\r\n    private countTreeNodes(root: INode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    public find(predicate: (item: T) => boolean): T {\r\n        if (this.root == null) return null;\r\n        return this.findRecursive(<INode<T>>this.root, predicate);\r\n    }\r\n    private findRecursive(root: INode<T>, predicate: (item: T) => boolean): T {\r\n        if (root == null) return null;\r\n        if (predicate(root.getData())) return root.getData();\r\n        let foundItem: T = this.findRecursive(root.getLeft(), predicate);\r\n        if (foundItem != null){\r\n            return foundItem;\r\n        }\r\n        return this.findRecursive(root.getRight(), predicate);\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (this.root == null) return;\r\n        this.forEachRecursive(this.root, action);\r\n    }\r\n    private forEachRecursive(root: INode<T>, action: (item: T) => void): void {\r\n        if (root == null) return;\r\n        this.forEachRecursive(root.getLeft(), action);\r\n        action(root.getData());\r\n        this.forEachRecursive(root.getRight(), action);\r\n    }\r\n    public getRootData(): T {\r\n        return this.root.getData();\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    public remove(item: T): boolean {\r\n        if(!this.contains(item)) return false;\r\n        this.delete(item);\r\n        return true;\r\n    }\r\n    public size(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    public toArray(): T[] {\r\n        const target: T[] = [];\r\n        if (this.isEmpty()) return target;\r\n        this.toArrayRecursive(<INode<T>>this.root, target);\r\n        return target;\r\n    }\r\n    private toArrayRecursive(root: INode<T>, target: T[]): void {\r\n        if (root == null) return;\r\n        this.toArrayRecursive(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toArrayRecursive(root.getRight(), target);\r\n    }\r\n    protected toInorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toInorderArray(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toInorderArray(root.getRight(), target);\r\n    }\r\n    protected toPostorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toPostorderArray(root.getLeft(), target);\r\n        this.toPostorderArray(root.getRight(), target);\r\n        target.push(root.getData());\r\n    }\r\n    protected toPreorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        target.push(root.getData());\r\n        this.toPreorderArray(root.getLeft(), target);\r\n        this.toPreorderArray(root.getRight(), target);\r\n    }\r\n    \r\n    /**\r\n     * Traverses the tree and applies the mapper function to each item.\r\n     * @param  mapper The function that will be applied to each item.\r\n     * @param  direction The direction of the traverse. (In-order, Pre-order, Post-order)\r\n     * @return An array containing all the items of the tree. Order is defined by direction.\r\n     */\r\n    public traverseAndMapToArray<R>(mapper: (item: T) => R, direction: TraverseType = \"INORDER\"): R[] {\r\n        let array: T[] = [];\r\n        switch(direction) {\r\n            case \"INORDER\":\r\n                this.toInorderArray(this.root, array);\r\n                break;\r\n            case \"PREORDER\":\r\n                this.toPreorderArray(this.root, array);\r\n                break;\r\n            case \"POSTORDER\":\r\n                this.toPostorderArray(this.root, array);\r\n                break;\r\n        }\r\n        return array.map(v => mapper(v));\r\n    }\r\n    /**\r\n     * Traverses the tree and applies the morpher function to each item.\r\n     * Returns a new tree with the morphed elements. Does not modify the original tree.\r\n     * Pre-order traversing is used.\r\n     * @param tree The tree that will be filled with the morphed items. This is normally an empty tree.\r\n     * @param morpher The function that will be applied to each item.\r\n     */\r\n    public traverseAndMorph<R>(tree: ITree<R>, morpher: (item: T) => R): ITree<R> {\r\n        this.traverseAndMorphRecursive(this.root, morpher, tree);\r\n        return tree;\r\n    }\r\n    private traverseAndMorphRecursive<R>(root: INode<T>, morpher: (item: T) => R, tree: ITree<R>): void {\r\n        if (root == null) return;\r\n        tree.insert(morpher(root.getData()));\r\n        this.traverseAndMorphRecursive(root.getLeft(), morpher, tree);\r\n        this.traverseAndMorphRecursive(root.getRight(), morpher, tree);\r\n    }\r\n\r\n    public abstract add(item: T): boolean;\r\n    public abstract delete(item: T): void;\r\n    public abstract insert(item: T): void;\r\n    // public abstract remove(item: T): boolean;\r\n    public abstract search(item: T): boolean;\r\n}","import { INode } from \"./INode\";\r\n\r\nexport class TreeNode<T> implements INode<T> {\r\n    private data: T;\r\n    private left: INode<T>;\r\n    private right: INode<T>;\r\n    public constructor(data?: T) {\r\n        this.data = data || null;\r\n    }\r\n    public getData(): T {\r\n        return this.data;\r\n    }\r\n    public getLeft(): INode<T> {\r\n        return this.left;\r\n    }\r\n    public getRight(): INode<T> {\r\n        return this.right;\r\n    }\r\n    public setData(data: T): void {\r\n        this.data = data;\r\n    }\r\n    public setLeft(node: INode<T>): void {\r\n        this.left = node;\r\n    }\r\n    public setRight(node: INode<T>): void {\r\n        this.right = node;\r\n    }\r\n}","import { AbstractTree } from \"./AbstractTree\";\r\nimport { TreeNode } from \"./TreeNode\";\r\n\r\n// Algorithm taken from https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/\r\nclass RedBlackNode<T> extends TreeNode<T> {\r\n    public static readonly RED   = 0;\r\n    public static readonly BLACK = 1;\r\n    private parent: RedBlackNode<T>;\r\n    private color: number;\r\n    public constructor(data: T) {\r\n        super(data);\r\n        this.setLeft(null);\r\n        this.setRight(null);\r\n        this.parent = null;\r\n        this.color = RedBlackNode.RED;\r\n    }\r\n    public getColor(): number { return this.color; }\r\n    public getParent(): RedBlackNode<T> { return this.parent; }\r\n    public getSibling(): RedBlackNode<T> {\r\n        if (this.parent == null) return null;\r\n        if (this.isOnLeft()) return this.parent.getRight() as RedBlackNode<T>;\r\n        return this.parent.getLeft() as RedBlackNode<T>;\r\n    }\r\n    public getUncle(): RedBlackNode<T> {\r\n        if (this.parent == null || this.parent.getParent() == null){\r\n            return null;\r\n        }\r\n        if (this.parent.isOnLeft()){\r\n            return this.parent.getParent().getRight() as RedBlackNode<T>;\r\n        }\r\n        return this.parent.getParent().getLeft() as RedBlackNode<T>;\r\n    }\r\n    public hasRedChild(): boolean {\r\n        return (this.getLeft() != null && (this.getLeft() as RedBlackNode<T>).getColor() === RedBlackNode.RED)\r\n            || (this.getRight() != null && (this.getRight() as RedBlackNode<T>).getColor() === RedBlackNode.RED);\r\n    }\r\n    public isOnLeft(): boolean {\r\n        return this.parent.getLeft() === this;\r\n    }\r\n    public moveDown(p: RedBlackNode<T>): void { //p: parentnode\r\n        if (this.parent != null) {\r\n            if (this.isOnLeft()) {\r\n                this.parent.setLeft(p);\r\n            } else {\r\n                this.parent.setRight(p);\r\n            }\r\n        }\r\n        p.setParent(this.parent);\r\n        this.parent = p;\r\n    }\r\n    public setColor(color: number): void { this.color = color; }\r\n    public setParent(parent: RedBlackNode<T>): void { this.parent = parent; }\r\n}\r\n\r\nexport class BinarySearchTree<T> extends AbstractTree<T> {\r\n    public constructor(comparator: Function){\r\n        super(comparator);\r\n        this.root = null;\r\n    }\r\n    public add(item: T): boolean {\r\n        if(this.search(item)) return false;\r\n        this.insert(item);\r\n        return true;\r\n    }\r\n    public delete(item: T): void {\r\n        if (!this.contains(item)) return;\r\n        let v: RedBlackNode<T> = this.searchNode(item);\r\n        this.deleteNode(v);\r\n    }\r\n    private deleteNode(v: RedBlackNode<T>): void {\r\n        let u: RedBlackNode<T> = this.findReplaceItem(v);\r\n        const bothBlack = ((u == null || u.getColor() === RedBlackNode.BLACK) && v.getColor() === RedBlackNode.BLACK);\r\n        let parent: RedBlackNode<T> = v.getParent();\r\n        if (u === null) {\r\n            if (v === this.root) {\r\n                this.root = null;\r\n            } else {\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(v);\r\n                } else {\r\n                    if (v.getSibling() != null) {\r\n                        v.getSibling().setColor(RedBlackNode.RED);\r\n                    }\r\n                }\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(null);\r\n                } else {\r\n                    parent.setRight(null);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (v.getLeft() == null || v.getRight() == null) {\r\n            if (v === this.root) {\r\n                v.setData(u.getData());\r\n                v.setLeft(null);\r\n                v.setRight(null);\r\n            } else {\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(u);\r\n                } else {\r\n                    parent.setRight(u);\r\n                }\r\n                u.setParent(parent);\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(u);\r\n                } else {\r\n                    u.setColor(RedBlackNode.BLACK);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        this.swapValues(u, v);\r\n        this.deleteNode(u);\r\n    }\r\n    private findReplaceItem(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        if (node.getLeft() != null && node.getRight() != null) {\r\n            return this.getSuccessor(node.getRight() as RedBlackNode<T>);\r\n        }\r\n        if (node.getLeft() == null && node.getRight() == null) {\r\n            return null;\r\n        }\r\n        if (node.getLeft() != null){\r\n            return node.getLeft() as RedBlackNode<T>;\r\n        }\r\n        return node.getRight() as RedBlackNode<T>;\r\n    }\r\n    private fixDoubleBlack(node: RedBlackNode<T>): void {\r\n        if (node === this.root) return;\r\n        let sibling = node.getSibling();\r\n        let parent  = node.getParent();\r\n        if (sibling == null) {\r\n            this.fixDoubleBlack(parent);\r\n        } else {\r\n            if (sibling.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.RED);\r\n                sibling.setColor(RedBlackNode.BLACK);\r\n                if (sibling.isOnLeft()) {\r\n                    this.rightRotate(parent);\r\n                } else {\r\n                    this.leftRotate(parent);\r\n                }\r\n                this.fixDoubleBlack(node);\r\n            } else {\r\n                if (sibling.hasRedChild()) {\r\n                    if ((sibling.getLeft() as RedBlackNode<T>) != null && (sibling.getLeft() as RedBlackNode<T>).getColor() === RedBlackNode.RED) {\r\n                        if (sibling.isOnLeft()) {\r\n                            (sibling.getLeft() as RedBlackNode<T>).setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            (sibling.getLeft() as RedBlackNode<T>).setColor(parent.getColor());\r\n                            this.rightRotate(sibling);\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    } else {\r\n                        if (sibling.isOnLeft()) {\r\n                            (sibling.getRight() as RedBlackNode<T>).setColor(parent.getColor());\r\n                            this.leftRotate(sibling);\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            (sibling.getRight() as RedBlackNode<T>).setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    }\r\n                    parent.setColor(RedBlackNode.BLACK);\r\n                } else {\r\n                    sibling.setColor(RedBlackNode.RED);\r\n                    if (parent.getColor() === RedBlackNode.BLACK) {\r\n                        this.fixDoubleBlack(parent);\r\n                    } else {\r\n                        parent.setColor(RedBlackNode.BLACK);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private fixDoubleRed(node: RedBlackNode<T>): void {\r\n        if (node === this.root){\r\n            node.setColor(RedBlackNode.BLACK);\r\n            return;\r\n        }\r\n        let parent: RedBlackNode<T> = node.getParent();\r\n        let grandParent: RedBlackNode<T> = parent.getParent();\r\n        let uncle: RedBlackNode<T> = node.getUncle();\r\n        if (parent.getColor() !== RedBlackNode.BLACK){\r\n            if (uncle != null && uncle.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.BLACK);\r\n                uncle.setColor(RedBlackNode.BLACK);\r\n                grandParent.setColor(RedBlackNode.RED);\r\n                this.fixDoubleRed(grandParent);\r\n            } else {\r\n                if (parent.isOnLeft()) {\r\n                    if (node.isOnLeft()) {\r\n                        this.swapColors(parent, grandParent);\r\n                    } else {\r\n                        this.leftRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    }\r\n                    this.rightRotate(grandParent);\r\n                } else {\r\n                    if (node.isOnLeft()) {\r\n                        this.rightRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    } else {\r\n                        this.swapColors(parent, grandParent);\r\n                    }\r\n                    this.leftRotate(grandParent);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private getSuccessor(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        let temp = node;\r\n        while (temp.getLeft() != null){\r\n            temp = temp.getLeft() as RedBlackNode<T>;\r\n        }\r\n        return temp;\r\n    }\r\n    public insert(item: T): void {\r\n        const node = new RedBlackNode<T>(item);\r\n        if (this.root == null) {\r\n            node.setColor(RedBlackNode.BLACK);\r\n            this.root = node;\r\n        } else {\r\n            const temp: RedBlackNode<T> = this.searchNode(item);\r\n            if (temp.getData() === item) {\r\n                return;\r\n            }\r\n            node.setParent(temp);\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                temp.setLeft(node);\r\n            } else {\r\n                temp.setRight(node);\r\n            }\r\n            this.fixDoubleRed(node);\r\n        }\r\n    }\r\n    private leftRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getRight();\r\n        if (node === this.root) {\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p as RedBlackNode<T>);\r\n        node.setRight(p.getLeft() as RedBlackNode<T>);\r\n        if (p.getLeft() != null) {\r\n            (p.getLeft() as RedBlackNode<T>).setParent(node);\r\n        }\r\n        p.setLeft(node);\r\n    }\r\n    private rightRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getLeft();\r\n        if (node === this.root){\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p as RedBlackNode<T>);\r\n        node.setLeft(p.getRight());\r\n        if (p.getRight() != null) {\r\n            (p.getRight() as RedBlackNode<T>).setParent(node);\r\n        }\r\n        p.setRight(node);\r\n    }\r\n    public search(item: T): boolean {\r\n        const node = this.searchNode(item);\r\n        if (node == null) return false;\r\n        return this.comparator(node.getData(), item) === 0;\r\n    }\r\n    private searchNode(item: T): RedBlackNode<T> {\r\n        let temp: RedBlackNode<T> = this.root as RedBlackNode<T>;\r\n        while (temp != null) {\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                if (temp.getLeft() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getLeft() as RedBlackNode<T>;\r\n                }\r\n            } else if (item === temp.getData()) {\r\n                break;\r\n            } else {\r\n                if (temp.getRight() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getRight() as RedBlackNode<T>;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n    private swapColors(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getColor();\r\n        u.setColor(v.getColor());\r\n        v.setColor(temp);\r\n    }\r\n    private swapValues(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getData();\r\n        u.setData(v.getData());\r\n        v.setData(temp);\r\n    }\r\n}","import { AbstractTree } from \"./AbstractTree\";\r\nimport { TreeNode } from \"./TreeNode\";\r\nexport class BinaryTree<T> extends AbstractTree<T> {\r\n    public constructor(comparator: Function) {\r\n        super(comparator);\r\n        this.root = null;\r\n    }\r\n    public add(item: T): boolean {\r\n        if(this.search(item)) return false;\r\n        this.insert(item);\r\n        return true;\r\n    }\r\n    public delete(item: T): void {\r\n        this.root = this.deleteRecursive(this.root as TreeNode<T>, item);\r\n    }\r\n    private deleteRecursive(root: TreeNode<T>, item: T): TreeNode<T> {\r\n        if (root == null) return null;\r\n        if (this.comparator(item, root.getData()) === 0) {\r\n            if (root.getLeft() == null && root.getRight() == null) {\r\n                return null;\r\n            }\r\n            if (root.getRight() == null) {\r\n                return root.getLeft() as TreeNode<T>;\r\n            }\r\n            if (root.getLeft() == null) {\r\n                return root.getRight() as TreeNode<T>;\r\n            }\r\n            const smallestValue = this.findSmallestValue(root.getRight() as TreeNode<T>);\r\n            root.setData(smallestValue);\r\n            root.setRight(this.deleteRecursive(root.getRight() as TreeNode<T>, smallestValue));\r\n            return root;\r\n        }\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.deleteRecursive(root.getLeft() as TreeNode<T>, item));\r\n            return root;\r\n        }\r\n        root.setRight(this.deleteRecursive(root.getRight() as TreeNode<T>, item));\r\n        return root;\r\n    }\r\n    private findSmallestValue(root: TreeNode<T>): T {\r\n        return root.getLeft() == null ? root.getData() : this.findSmallestValue(root.getLeft() as TreeNode<T>);\r\n    }\r\n    public insert(item: T): void {\r\n        this.root = this.insertRecursive(this.root as TreeNode<T>, item);\r\n    }\r\n    private insertRecursive(root: TreeNode<T>, item: T): TreeNode<T> {\r\n        if (root == null) return new TreeNode<T>(item);\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.insertRecursive(root.getLeft() as TreeNode<T>, item));\r\n        } else if (this.comparator(item, root.getData()) > 0) {\r\n            root.setRight(this.insertRecursive(root.getRight() as TreeNode<T>, item));\r\n        } else {\r\n            return root;\r\n        }\r\n        return root;\r\n    }\r\n    public search(item: T): boolean {\r\n       return this.searchTree(this.root as TreeNode<T>, item);\r\n    }\r\n    private searchTree(root: TreeNode<T>, item: T): boolean {\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        if (root.getLeft() != null) {\r\n            if (this.searchTree(root.getLeft() as TreeNode<T>, item)) return true;\r\n        }\r\n        if (root.getRight() != null) {\r\n            if (this.searchTree(root.getRight() as TreeNode<T>, item)) return true;\r\n        }\r\n        return false;\r\n    }\r\n}","export class ArgumentNullException extends Error {\r\n    name = \"ArgumentNullException\";\r\n    message = \"object is null.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","export class ArgumentOutOfRangeException extends Error {\r\n    public name: string = \"ArgumentOutOfRangeException\";\r\n    public message: string = \"arrayIndex is out of range.\";\r\n    public constructor(message: string) {\r\n        super();\r\n        this.message = message;\r\n    }\r\n}","export class ArgumentException extends Error {\r\n    public name = \"ArgumentException\";\r\n    public message = \"Invalid argument.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if(message) {\r\n            this.message = message;\r\n        }\r\n    }\r\n}","export class InvalidOperationException extends Error {\r\n    name = \"InvalidOperationException\";\r\n    message = \"Invalid operation.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","import { IList } from \"./IList\";\r\nimport { ArgumentNullException } from \"../exceptions/ArgumentNullException\";\r\nimport { ArgumentOutOfRangeException } from \"../exceptions/ArgumentOutOfRangeException\";\r\nimport { ArgumentException } from \"../exceptions/ArgumentException\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\nimport { IQueue } from \"../queue/IQueue\";\r\nimport { IDeque } from \"../queue/IDeque\";\r\n\r\nexport class List<T> implements IList<T>, IQueue<T>, IDeque<T> {\r\n    private data: T[] = [];\r\n    public constructor(data?: T[]) {\r\n        if(data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public add(item: T): boolean {\r\n        this.data.push(item);\r\n        return true;\r\n    }\r\n    public clear() {\r\n        this.data.length = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return  this.indexOf(item) > -1;\r\n    }\r\n    public dequeue(): T {\r\n        if (this.isEmpty()) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        return item;\r\n    }\r\n    public dequeueLast(): T {\r\n        if (this.isEmpty()) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        const item = this.data[this.data.length - 1];\r\n        this.data.splice(this.data.length-1, 1);\r\n        return item;\r\n    }\r\n    public enqueue(item: T): void {\r\n        this.add(item);\r\n    }\r\n    public enqueueFirst(item: T): void {\r\n        this.insert(0, item);\r\n    }\r\n    public exists(predicate: (item: T) => boolean): boolean {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        return this.data.some(predicate);\r\n    }\r\n    public find(predicate: (item: T) => boolean): T|null {\r\n        const item = this.data.find(predicate);\r\n        return item || null;\r\n    }\r\n    public findAll(predicate: (item: T) => boolean): List<T> {\r\n        const foundData = this.data.filter(predicate);\r\n        return new List<T>(foundData);\r\n    }\r\n    public findIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        \r\n        startIndex = startIndex || 0;\r\n        count      = count || this.size()-1;\r\n\r\n        if (startIndex! < 0 || startIndex >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.size()) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        \r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex; ix < startIndex+count; ++ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public findLast(predicate: (item: T) => boolean): T {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        let found = false;\r\n        let foundItem: T = null;\r\n        for (let ix = this.data.length - 1; ix >= 0; --ix) {\r\n            const elem = this.data[ix];\r\n            found = predicate(elem);\r\n            if (found) {\r\n                foundItem = elem;\r\n                break;\r\n            }\r\n        }\r\n        return foundItem;\r\n    }\r\n    public findLastIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        if (startIndex < 0 || startIndex >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.size()) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        startIndex = startIndex || 0;\r\n        count      = count || this.size();\r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex+count-1; ix >= startIndex; --ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (!action) {\r\n            throw new ArgumentNullException(\"action is null.\");\r\n        }\r\n        this.data.forEach(d => d ? action(d) : void 0);\r\n    }\r\n    public get(index: number): T {\r\n        if (index == null) {\r\n            throw new ArgumentNullException(\"index is null.\");\r\n        }\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.size()}.`);\r\n        }\r\n        return this.data[index];\r\n    }\r\n    public indexOf(item: T): number {\r\n        return this.data.findIndex(d => d === item);\r\n    }\r\n    public insert(index: number, item: T) {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index !== 0 && index >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.size()}.`);\r\n        }\r\n        this.data.splice(index, 0, item);\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n    public lastIndexOf(item: T): number {\r\n        return this.data.lastIndexOf(item);\r\n    }\r\n    public peek(): T {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        return this.get(0);\r\n    }\r\n    public peekLast(): T {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        return this.get(this.size() - 1);\r\n    }\r\n    public poll(): T {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        return item;\r\n    }\r\n    public pollLast(): T {\r\n        if (this.isEmpty()) return null;\r\n        const item = this.data[this.size() - 1];\r\n        this.data.splice(this.size() - 1, 1);\r\n        return item;\r\n    }\r\n    public remove(item: T): boolean {\r\n        const index = this.findIndex(d => d === item);\r\n        if (index === -1) return false;\r\n        this.removeAt(index);\r\n        return true;\r\n    }\r\n    public removeAll(predicate: (value: T) => boolean): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        const preCount = this.data.length;\r\n        this.data = this.data.filter(d => !predicate(d));\r\n        return preCount - this.data.length;\r\n    }\r\n    public removeAt(index: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.size()}.`);\r\n        }\r\n        this.data.splice(index, 1);\r\n    }\r\n    public removeRange(index: number, count: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (index+count > this.size()) {\r\n            throw new ArgumentException(\"index and count do not denote a valid range of elements in the list.\");\r\n        }\r\n        let removedCount = 0;\r\n        while(removedCount < count) {\r\n            this.removeAt(index);\r\n            removedCount++;\r\n        }\r\n    }\r\n    public reverse(): void {\r\n        this.data.reverse();\r\n    }\r\n    public set(index: number, item: T): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.size()}.`);\r\n        }\r\n        this.data[index] = item;\r\n    }\r\n    public size(): number {\r\n        return this.data.length;\r\n    }\r\n    public sort(comparer?: (e1: T, e2: T) => number): void {\r\n        if (!comparer) {\r\n            comparer = (e1: T, e2: T) => e1 > e2 ? 1 : -1;\r\n        }\r\n        this.data.sort(comparer);\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n}","import { ISet } from \"./ISet\";\r\nimport { BinarySearchTree } from \"../tree/BinarySearchTree\";\r\n\r\nexport class TreeSet<T> implements ISet<T> {\r\n    private comparator: (v1: T, v2: T) => number = (v1: T|any, v2: T|any) => v1-v2;\r\n    private tree: BinarySearchTree<T>;\r\n    public constructor(comparator?: (v1: T, v2: T) => number) {\r\n        if (comparator) this.comparator = comparator;\r\n        this.tree = new BinarySearchTree<T>(this.comparator);\r\n    }\r\n    public add(item: T): boolean {\r\n        if (this.tree.search(item)) return false;\r\n        this.tree.insert(item);\r\n        return true;\r\n    }\r\n    public clear(): void {\r\n        this.tree.clear();\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.tree.contains(item);\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.tree.isEmpty();\r\n    }\r\n    public remove(item: T): boolean {\r\n        return this.tree.remove(item);\r\n    }\r\n    public size(): number {\r\n        return this.tree.size();\r\n    }\r\n    public toArray(): T[] {\r\n        return this.tree.toArray();\r\n    }\r\n}"],"names":["AbstractTree","constructor","comparator","clear","root","contains","item","this","containsRecursive","getData","getLeft","getRight","countTreeNodes","find","predicate","findRecursive","foundItem","forEach","action","forEachRecursive","getRootData","isEmpty","remove","delete","size","toArray","target","toArrayRecursive","push","toInorderArray","toPostorderArray","toPreorderArray","traverseAndMapToArray","mapper","direction","array","map","v","traverseAndMorph","tree","morpher","traverseAndMorphRecursive","insert","TreeNode","data","left","right","setData","setLeft","node","setRight","RedBlackNode","parent","color","RED","getColor","getParent","getSibling","isOnLeft","getUncle","hasRedChild","moveDown","p","setParent","setColor","BinarySearchTree","add","search","searchNode","deleteNode","u","findReplaceItem","bothBlack","BLACK","swapValues","fixDoubleBlack","getSuccessor","sibling","rightRotate","leftRotate","fixDoubleRed","grandParent","uncle","swapColors","temp","BinaryTree","deleteRecursive","smallestValue","findSmallestValue","insertRecursive","searchTree","ArgumentNullException","message","Error","ArgumentOutOfRangeException","ArgumentException","InvalidOperationException","List","length","indexOf","dequeue","splice","dequeueLast","enqueue","enqueueFirst","exists","some","findAll","foundData","filter","findIndex","startIndex","count","foundIndex","ix","findLast","elem","findLastIndex","d","get","index","lastIndexOf","peek","peekLast","poll","pollLast","removeAt","removeAll","preCount","removeRange","removedCount","reverse","set","sort","comparer","e1","e2","TreeSet","v1","v2"],"mappings":"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"}