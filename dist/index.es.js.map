{"version":3,"file":"index.es.js","sources":["../src/exceptions/ArgumentNullException.ts","../src/exceptions/ArgumentOutOfRangeException.ts","../src/exceptions/ArgumentException.ts","../src/list/List.ts","../src/exceptions/InvalidOperationException.ts","../src/queue/Queue.ts","../src/stack/Stack.ts","../src/tree/BinaryTreeNode.ts","../src/tree/BinaryTree.ts","../src/tree/BinarySearchTree.ts"],"sourcesContent":["export class ArgumentNullException extends Error {\r\n    name = \"ArgumentNullException\";\r\n    message = \"object is null.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","export class ArgumentOutOfRangeException extends Error {\r\n    public name: string = \"ArgumentOutOfRangeException\";\r\n    public message: string = \"arrayIndex is out of range.\";\r\n    public constructor(message: string) {\r\n        super();\r\n        this.message = message;\r\n    }\r\n}","export class ArgumentException extends Error {\r\n    public name = \"ArgumentException\";\r\n    public message = \"Invalid argument.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if(message) {\r\n            this.message = message;\r\n        }\r\n    }\r\n}","import { IList } from \"./IList\";\r\nimport { ArgumentNullException } from \"../exceptions/ArgumentNullException\";\r\nimport { ArgumentOutOfRangeException } from \"../exceptions/ArgumentOutOfRangeException\";\r\nimport { ArgumentException } from \"../exceptions/ArgumentException\";\r\n\r\nexport class List<T> implements IList<T>, IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    // private enumerator: IEnumerator<T> = null;\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]){\r\n        if(data) {\r\n            this.data = [...data];\r\n            this.count = this.data.length;\r\n        }\r\n    }\r\n    public add(item: T) {\r\n        this.data.push(item);\r\n        this.count++;\r\n    }\r\n    public clear() {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return  this.indexOf(item) > -1;\r\n    }\r\n    // public copyTo(array: T[], arrayIndex: number): void {\r\n    //     if (!array) {\r\n    //         throw new ArgumentNullException(\"array is null.\");\r\n    //     }\r\n    //     if (arrayIndex < 0) {\r\n    //         throw new ArgumentOutOfRangeException(\"array index is less than 0.\");\r\n    //     }\r\n    //     let index = arrayIndex;\r\n    //     for(const item of this.data) {\r\n    //         array.splice(index, 0, item);\r\n    //         index++;\r\n    //     }\r\n    // }\r\n    public exists(predicate: (item: T) => boolean): boolean {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        return this.data.some(predicate);\r\n    }\r\n    public find(predicate: (item: T) => boolean): T|null {\r\n        const item = this.data.find(predicate);\r\n        return item || null;\r\n    }\r\n    public findAll(predicate: (item: T) => boolean): List<T> {\r\n        const foundData = this.data.filter(predicate);\r\n        return new List<T>(foundData);\r\n    }\r\n    public findIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        \r\n        startIndex = startIndex || 0;\r\n        count      = count || this.Count-1;\r\n\r\n        if (startIndex! < 0 || startIndex >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        \r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex; ix < startIndex+count; ++ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public findLast(predicate: (item: T) => boolean): T {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        let found = false;\r\n        let foundItem: T = null;\r\n        for (let ix = this.data.length - 1; ix >= 0; --ix) {\r\n            const elem = this.data[ix];\r\n            found = predicate(elem);\r\n            if (found) {\r\n                foundItem = elem;\r\n                break;\r\n            }\r\n        }\r\n        return foundItem;\r\n    }\r\n    public findLastIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        if (startIndex < 0 || startIndex >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        startIndex = startIndex || 0;\r\n        count      = count || this.Count;\r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex+count-1; ix >= startIndex; --ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (!action) {\r\n            throw new ArgumentNullException(\"action is null.\");\r\n        }\r\n        this.data.forEach(d => d ? action(d) : void 0);\r\n    }\r\n    public get(index: number): T {\r\n        if (index == null) {\r\n            throw new ArgumentNullException(\"index is null.\");\r\n        }\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        return this.data[index];\r\n    }\r\n    // public getEnumerator(): IEnumerator<T> {\r\n    //     return this.getListEnumerator();\r\n    // }\r\n    // private getListEnumerator(): IBaseEnumerator {\r\n    //     return new ListEnum(this.data);\r\n    // }\r\n    public indexOf(item: T): number {\r\n        return this.data.findIndex(d => d === item);\r\n    }\r\n    public insert(index: number, item: T) {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data.splice(index, 0, item);\r\n        this.count++;\r\n    }\r\n    public lastIndexOf(item: T): number {\r\n        return this.data.lastIndexOf(item);\r\n    }\r\n    public remove(item: T): boolean {\r\n        const index = this.findIndex(d => d === item);\r\n        if (index === -1) return false;\r\n        this.removeAt(index);\r\n        return true;\r\n    }\r\n    public removeAll(predicate: (value: T) => boolean): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        const preCount = this.Count;\r\n        this.data = this.data.filter(d => !predicate(d));\r\n        this.count = this.data.length;\r\n        return preCount - this.count;\r\n    }\r\n    public removeAt(index: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data.splice(index, 1);\r\n        this.count--;\r\n    }\r\n    public removeRange(index: number, count: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (index+count > this.Count) {\r\n            throw new ArgumentException(\"index and count do not denote a valid range of elements in the list.\");\r\n        }\r\n        let removedCount = 0;\r\n        while(removedCount < count) {\r\n            this.removeAt(index);\r\n            removedCount++;\r\n        }\r\n    }\r\n    public reverse(): void {\r\n        this.data.reverse();\r\n    }\r\n    public set(index: number, item: T): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data[index] = item;\r\n    }\r\n    public sort(comparer?: (e1: T, e2: T) => number): void {\r\n        if (!comparer) {\r\n            comparer = (e1: T, e2: T) => e1 > e2 ? 1 : -1;\r\n        }\r\n        this.data.sort(comparer);\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n        // if (!this.enumerator) {\r\n        //     this.enumerator = this.getEnumerator();\r\n        // }\r\n        // if(this.enumerator.moveNext()) {\r\n        //     return { done: false, value: this.enumerator.Current };\r\n        // }\r\n        // this.enumerator.reset();\r\n        // return { done: true, value: null };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n\r\n    public get Count() { return this.count; }\r\n}\r\n\r\n// class ListEnum<T> implements IBaseEnumerator {\r\n//     private data: T[];\r\n//     private position: number = -1;\r\n//     public constructor(data: T[]){\r\n//         this.data = data;\r\n//     }\r\n//     public moveNext(): boolean {\r\n//         this.position++;\r\n//         return this.position < this.data.length;\r\n//     }\r\n//     public reset(): void {\r\n//         this.position = -1;\r\n//     }\r\n//     public get Current(): T {\r\n//         return this.data[this.position];\r\n//     }\r\n// }","export class InvalidOperationException extends Error {\r\n    name = \"InvalidOperationException\";\r\n    message = \"Invalid operation.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","import { ICollection } from \"../core/ICollection\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\n\r\nexport class Queue<T> implements IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]) {\r\n        if (data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public clear(): void {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.data.findIndex(d => d === item) > -1;\r\n    }\r\n    public dequeue(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        this.count--;\r\n        return item;\r\n    }\r\n    public enqueue(item: T): void {\r\n        this.data.push(item);\r\n        this.count++;\r\n    }\r\n    public peek(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        return this.data[0];\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n\r\n    public get Count() { return this.count; }\r\n}","import { ICollection } from \"../core/ICollection\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\n\r\nexport class Stack<T> implements IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]) {\r\n        if (data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public clear(): void {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.data.findIndex(d => d === item) > -1;\r\n    }\r\n    public peek(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"stack is empty.\");\r\n        }\r\n        return this.data[0];\r\n    }\r\n    public pop(): T {\r\n        if (this.count === 0) {\r\n            throw new InvalidOperationException(\"stack is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        this.count--;\r\n        return item;\r\n    }\r\n    public push(item: T): void {\r\n        this.data.splice(0, 0, item);\r\n        this.count++;\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n\r\n    public get Count() { return this.count; }\r\n}","export class BinaryTreeNode<T extends any> {\r\n    private left: BinaryTreeNode<T>;\r\n    private right: BinaryTreeNode<T>;\r\n    private data: T;\r\n    public constructor(rootData?: T) {\r\n        if (rootData) this.data = rootData;\r\n    }\r\n    public getLeft(): BinaryTreeNode<T> {\r\n        return this.left;\r\n    }\r\n    public getRight(): BinaryTreeNode<T> {\r\n        return this.right;\r\n    }\r\n    public setLeft(node: BinaryTreeNode<T>): void {\r\n        this.left = node;\r\n    }\r\n    public setRight(node: BinaryTreeNode<T>): void {\r\n        this.right = node;\r\n    }\r\n    public setData(data: T): void {\r\n        this.data = data;\r\n    }\r\n    public getData(): T {\r\n        return this.data;\r\n    }\r\n}","import { BinaryTreeNode } from \"./BinaryTreeNode\";\r\n\r\nexport declare type TraverseType = \"INORDER\" | \"PREORDER\" | \"POSTORDER\";\r\nexport class BinaryTree<T> {\r\n    private comparator: Function = (v1:T|any, v2:T|any) => v1 - v2;\r\n    private root: BinaryTreeNode<T>;\r\n    public constructor(comparator?: Function) {\r\n        this.root = null;\r\n        if (comparator) this.comparator = comparator;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.containsRecursive(this.root, item);\r\n    }\r\n    private containsRecursive(root: BinaryTreeNode<T>, item: T): boolean {\r\n        if (root == null) return false;\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        return this.comparator(item, root.getData()) < 0\r\n            ? this.containsRecursive(root.getLeft(), item)\r\n            : this.containsRecursive(root.getRight(), item);\r\n    }\r\n    public insert(item: T): void {\r\n        this.root = this.insertRecursive(this.root, item);\r\n    }\r\n    private insertRecursive(root: BinaryTreeNode<T>, item: T): BinaryTreeNode<T> {\r\n        if (root == null) return new BinaryTreeNode<T>(item);\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.insertRecursive(root.getLeft(), item));\r\n        } else if (this.comparator(item, root.getData()) > 0) {\r\n            root.setRight(this.insertRecursive(root.getRight(), item));\r\n        } else {\r\n            return root;\r\n        }\r\n        return root;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    public countNodes(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    private countTreeNodes(root: BinaryTreeNode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    public delete(item: T): void {\r\n        this.root = this.deleteRecursive(this.root, item);\r\n    }\r\n    private deleteRecursive(root: BinaryTreeNode<T>, item: T): BinaryTreeNode<T> {\r\n        if (root == null) return null;\r\n        if (this.comparator(item, root.getData()) === 0) {\r\n            if (root.getLeft() == null && root.getRight() == null) {\r\n                return null;\r\n            }\r\n            if (root.getRight() == null) {\r\n                return root.getLeft();\r\n            }\r\n            if (root.getLeft() == null) {\r\n                return root.getRight();\r\n            }\r\n            const smallestValue = this.findSmallestValue(root.getRight());\r\n            root.setData(smallestValue);\r\n            root.setRight(this.deleteRecursive(root.getRight(), smallestValue));\r\n            return root;\r\n        }\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.deleteRecursive(root.getLeft(), item));\r\n            return root;\r\n        }\r\n        root.setRight(this.deleteRecursive(root.getRight(), item));\r\n        return root;\r\n    }\r\n    public find(predicate: (item: T) => boolean): T {\r\n        if (this.root == null) return null;\r\n        return this.findRecursive(this.root, predicate);\r\n    }\r\n    private findRecursive(root: BinaryTreeNode<T>, predicate: (item: T) => boolean): T {\r\n        if (root == null) return null;\r\n        if (predicate(root.getData())) return root.getData();\r\n        let foundItem: T = this.findRecursive(root.getLeft(), predicate);\r\n        if (foundItem != null){\r\n            return foundItem;\r\n        }\r\n        return this.findRecursive(root.getRight(), predicate);\r\n\r\n    }\r\n    private findSmallestValue(root: BinaryTreeNode<T>): T {\r\n        return root.getLeft() == null ? root.getData() : this.findSmallestValue(root.getLeft());\r\n    }\r\n    public search(item: T): boolean {\r\n       return this.searchTree(this.root, item);\r\n    }\r\n    private searchTree(root: BinaryTreeNode<T>, item: T): boolean {\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        if (root.getLeft() != null) {\r\n            if (this.searchTree(root.getLeft(), item)) return true;\r\n        }\r\n        if (root.getRight() != null) {\r\n            if (this.searchTree(root.getRight(), item)) return true;\r\n        }\r\n        return false;\r\n    }\r\n    public traverseAndMap(mapper: (item: T) => T): BinaryTree<T> {\r\n        if (this.root == null) return null;\r\n        this.traverseAndMapRecursive(this.root, mapper);\r\n        return this;\r\n    }\r\n    private traverseAndMapRecursive(root: BinaryTreeNode<T>, mapper: (item: T) => T): void {\r\n        if (root == null) return;\r\n        this.traverseAndMapRecursive(root.getLeft(), mapper);\r\n        root.setData(mapper(root.getData()));\r\n        this.traverseAndMapRecursive(root.getRight(), mapper);\r\n    }\r\n    public traverseAndMapToArray<R>(mapper: (item: T) => R, direction: TraverseType = \"INORDER\"): R[] {\r\n        let array: T[] = [];\r\n        switch(direction) {\r\n            case \"INORDER\":\r\n                this.toArray(array, \"INORDER\");\r\n                break;\r\n            case \"PREORDER\":\r\n                this.toArray(array, \"PREORDER\");\r\n                break;\r\n            case \"POSTORDER\":\r\n                this.toArray(array, \"POSTORDER\");\r\n                break;\r\n        }\r\n        return array.map(v => mapper(v));\r\n    }\r\n    public traverseAndMorph<R>(morpher: (item: T) => R, comparator?: Function): BinaryTree<R> {\r\n        const compare  = comparator || this.comparator;\r\n        const tree     = new BinaryTree<R>(compare);\r\n        let array: T[] = [];\r\n        this.toArray(array);\r\n        array.forEach(e => {\r\n            const morphedItem = morpher(e);\r\n            tree.insert(morphedItem);\r\n        });\r\n        return tree;\r\n    }\r\n    public toArray(target: T[], direction: TraverseType = \"INORDER\"): T[] {\r\n        switch (direction) {\r\n            case \"INORDER\":\r\n                this.toInorderArray(this.root, target);\r\n                return target;\r\n            case \"PREORDER\":\r\n                this.toPreorderArray(this.root, target);\r\n                return target;\r\n            case \"POSTORDER\":\r\n                this.toPostorderArray(this.root, target);\r\n                return target;\r\n            default:\r\n                this.toInorderArray(this.root, target);\r\n                return target;\r\n        }\r\n    }\r\n    private toInorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toInorderArray(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toInorderArray(root.getRight(), target);\r\n    }\r\n    private toPostorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toPostorderArray(root.getLeft(), target);\r\n        this.toPostorderArray(root.getRight(), target);\r\n        target.push(root.getData());\r\n    }\r\n    private toPreorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        target.push(root.getData());\r\n        this.toPreorderArray(root.getLeft(), target);\r\n        this.toPreorderArray(root.getRight(), target);\r\n    }\r\n}","// Algorithm taken from https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/\r\nclass RedBlackNode<T> {\r\n    public static readonly RED   = 0;\r\n    public static readonly BLACK = 1;\r\n    private data: T;\r\n    private left: RedBlackNode<T>;\r\n    private parent: RedBlackNode<T>;\r\n    private right: RedBlackNode<T>;\r\n    private color: number;\r\n    public constructor(data: T) {\r\n        this.parent = this.left = this.right = null;\r\n        this.color = RedBlackNode.RED;\r\n        this.data  = data;\r\n    }\r\n    public getData(): T { return this.data; }\r\n    public getColor(): number { return this.color; }\r\n    public getLeft(): RedBlackNode<T> { return this.left; }\r\n    public getParent(): RedBlackNode<T> { return this.parent; }\r\n    public getRight(): RedBlackNode<T> { return this.right; }\r\n    public getSibling(): RedBlackNode<T> {\r\n        if (this.parent == null) return null;\r\n        if (this.isOnLeft()) return this.parent.getRight();\r\n        return this.parent.getLeft();\r\n    }\r\n    public getUncle(): RedBlackNode<T> {\r\n        if (this.parent == null || this.parent.getParent() == null){\r\n            return null;\r\n        }\r\n        if (this.parent.isOnLeft()){\r\n            return this.parent.getParent().getRight();\r\n        }\r\n        return this.parent.getParent().getLeft();\r\n    }\r\n    public hasRedChild(): boolean {\r\n        return (this.left != null && this.left.color === RedBlackNode.RED)\r\n            || (this.right != null && this.right.color === RedBlackNode.RED);\r\n    }\r\n    public isOnLeft(): boolean {\r\n        return this.parent.getLeft() === this;\r\n    }\r\n    public moveDown(p: RedBlackNode<T>): void { //p: parentnode\r\n        if (this.parent != null) {\r\n            if (this.isOnLeft()) {\r\n                this.parent.setLeft(p);\r\n            } else {\r\n                this.parent.setRight(p);\r\n            }\r\n        }\r\n        p.setParent(this.parent);\r\n        this.parent = p;\r\n    }\r\n    public setColor(color: number): void { this.color = color; }\r\n    public setData(data: T): void { this.data = data; }\r\n    public setLeft(left: RedBlackNode<T>): void { this.left = left; }\r\n    public setParent(parent: RedBlackNode<T>): void { this.parent = parent; }\r\n    public setRight(right: RedBlackNode<T>): void { this.right = right; }\r\n}\r\n\r\nexport class BinarySearchTree<T> {\r\n    private root: RedBlackNode<T>;\r\n    private comparator: Function = (v1:T|any, v2:T|any) => v1 - v2;\r\n    public constructor(comparator?: Function){\r\n        if (comparator) this.comparator = comparator;\r\n        this.root = null;\r\n    }\r\n    /**\r\n     * Returns the number of nodes in the tree.\r\n     */\r\n    public countNodes(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    private countTreeNodes(root: RedBlackNode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    /**\r\n     * Removes an item from the tree.\r\n     * @param item The item to be removed from tree.\r\n     */\r\n    public delete(item: T): void {\r\n        if (this.root == null) return;\r\n        let v: RedBlackNode<T> = this.searchNode(item);\r\n        if (v.getData() !== item) {\r\n            return;\r\n        }\r\n        this.deleteNode(v);\r\n    }\r\n    private deleteNode(v: RedBlackNode<T>): void {\r\n        let u: RedBlackNode<T> = this.findReplaceItem(v);\r\n        const bothBlack = ((u == null || u.getColor() === RedBlackNode.BLACK) && v.getColor() === RedBlackNode.BLACK);\r\n        let parent: RedBlackNode<T> = v.getParent();\r\n        if (u === null) {\r\n            if (v === this.root) {\r\n                this.root = null;\r\n            } else {\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(v);\r\n                } else {\r\n                    if (v.getSibling() != null) {\r\n                        v.getSibling().setColor(RedBlackNode.RED);\r\n                    }\r\n                }\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(null);\r\n                } else {\r\n                    parent.setRight(null);\r\n                }\r\n            }\r\n            // v = null;\r\n            return;\r\n        }\r\n        if (v.getLeft() == null || v.getRight() == null) {\r\n            if (v === this.root) {\r\n                v.setData(u.getData());\r\n                v.setLeft(null);\r\n                v.setRight(null);\r\n                // u = null;\r\n            } else {\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(u);\r\n                } else {\r\n                    parent.setRight(u);\r\n                }\r\n                // v = null;\r\n                u.setParent(parent);\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(u);\r\n                } else {\r\n                    u.setColor(RedBlackNode.BLACK);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        this.swapValues(u, v);\r\n        this.deleteNode(u);\r\n    }\r\n    private findReplaceItem(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        if (node.getLeft() != null && node.getRight() != null) {\r\n            return this.getSuccessor(node.getRight());\r\n        }\r\n        if (node.getLeft() == null && node.getRight() == null) {\r\n            return null;\r\n        }\r\n        if (node.getLeft() != null){\r\n            return node.getLeft();\r\n        }\r\n        return node.getRight();\r\n    }\r\n    private fixDoubleBlack(node: RedBlackNode<T>): void {\r\n        if (node === this.root) return;\r\n        let sibling = node.getSibling();\r\n        let parent  = node.getParent();\r\n        if (sibling == null) {\r\n            this.fixDoubleBlack(parent);\r\n        } else {\r\n            if (sibling.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.RED);\r\n                sibling.setColor(RedBlackNode.BLACK);\r\n                if (sibling.isOnLeft()) {\r\n                    this.rightRotate(parent);\r\n                } else {\r\n                    this.leftRotate(parent);\r\n                }\r\n                this.fixDoubleBlack(node);\r\n            } else {\r\n                if (sibling.hasRedChild()) {\r\n                    if (sibling.getLeft() != null && sibling.getLeft().getColor() === RedBlackNode.RED) {\r\n                        if (sibling.isOnLeft()) {\r\n                            sibling.getLeft().setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            sibling.getLeft().setColor(parent.getColor());\r\n                            this.rightRotate(sibling);\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    } else {\r\n                        if (sibling.isOnLeft()) {\r\n                            sibling.getRight().setColor(parent.getColor());\r\n                            this.leftRotate(sibling);\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            sibling.getRight().setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    }\r\n                    parent.setColor(RedBlackNode.BLACK);\r\n                } else {\r\n                    sibling.setColor(RedBlackNode.RED);\r\n                    if (parent.getColor() === RedBlackNode.BLACK) {\r\n                        this.fixDoubleBlack(parent);\r\n                    } else {\r\n                        parent.setColor(RedBlackNode.BLACK);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private fixRedRed(node: RedBlackNode<T>): void {\r\n        if (node === this.root){\r\n            node.setColor(RedBlackNode.BLACK);\r\n            return;\r\n        }\r\n        let parent: RedBlackNode<T> = node.getParent();\r\n        let grandParent: RedBlackNode<T> = parent.getParent();\r\n        let uncle: RedBlackNode<T> = node.getUncle();\r\n        if (parent.getColor() !== RedBlackNode.BLACK){\r\n            if (uncle != null && uncle.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.BLACK);\r\n                uncle.setColor(RedBlackNode.BLACK);\r\n                grandParent.setColor(RedBlackNode.RED);\r\n                this.fixRedRed(grandParent);\r\n            } else {\r\n                if (parent.isOnLeft()) {\r\n                    if (node.isOnLeft()) {\r\n                        this.swapColors(parent, grandParent);\r\n                    } else {\r\n                        this.leftRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    }\r\n                    this.rightRotate(grandParent);\r\n                } else {\r\n                    if (node.isOnLeft()) {\r\n                        this.rightRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    } else {\r\n                        this.swapColors(parent, grandParent);\r\n                    }\r\n                    this.leftRotate(grandParent);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the root node of the tree.\r\n     */\r\n    public getRoot(): RedBlackNode<T> {\r\n        return this.root;\r\n    }\r\n    private getSuccessor(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        let temp = node;\r\n        while (temp.getLeft() != null){\r\n            temp = temp.getLeft();\r\n        }\r\n        return temp;\r\n    }\r\n    /**\r\n     * Inserts an item to the tree.\r\n     * @param item Item to be inserted.\r\n     */\r\n    public insert(item: T): void {\r\n        const node = new RedBlackNode<T>(item);\r\n        if (this.root == null) {\r\n            node.setColor(RedBlackNode.BLACK);\r\n            this.root = node;\r\n        } else {\r\n            const temp: RedBlackNode<T> = this.searchNode(item);\r\n            if (temp.getData() === item) {\r\n                return;\r\n            }\r\n            node.setParent(temp);\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                temp.setLeft(node);\r\n            } else {\r\n                temp.setRight(node);\r\n            }\r\n            this.fixRedRed(node);\r\n        }\r\n    }\r\n    /**\r\n     * Checks whether the tree is empty or not.\r\n     */\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    private leftRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getRight();\r\n        if (node === this.root) {\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p);\r\n        node.setRight(p.getLeft());\r\n        if (p.getLeft() != null) {\r\n            p.getLeft().setParent(node);\r\n        }\r\n        p.setLeft(node);\r\n    }\r\n    private rightRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getLeft();\r\n        if (node === this.root){\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p);\r\n        node.setLeft(p.getRight());\r\n        if (p.getRight() != null) {\r\n            p.getRight().setParent(node);\r\n        }\r\n        p.setRight(node);\r\n    }\r\n    /**\r\n     * Searchs an item in the tree.\r\n     * Returns the node the item belongs to,\r\n     * or null if item does not exists in tree.\r\n     */\r\n    public search(item: T): T {\r\n        const node = this.searchNode(item);\r\n        return node.getData();\r\n    }\r\n    private searchNode(item: T): RedBlackNode<T> {\r\n        let temp: RedBlackNode<T> = this.root;\r\n        while (temp != null) {\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                if (temp.getLeft() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getLeft();\r\n                }\r\n            } else if (item === temp.getData()) {\r\n                break;\r\n            } else {\r\n                if (temp.getRight() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getRight();\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n    private swapColors(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getColor();\r\n        u.setColor(v.getColor());\r\n        v.setColor(temp);\r\n    }\r\n    private swapValues(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getData();\r\n        u.setData(v.getData());\r\n        v.setData(temp);\r\n    }\r\n    /**\r\n     * Maps the tree data into an array inorderly.\r\n     * @param target The array that the data will be mapped into.\r\n     */\r\n    public toArray(target: T[]=[]): T[] {\r\n        if (this.isEmpty()) return target;\r\n        this.toArrayRecursive(this.root, target);\r\n        return target;\r\n    }\r\n    private toArrayRecursive(root: RedBlackNode<T>, target: T[]): void {\r\n        if (root == null) return;\r\n        this.toArrayRecursive(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toArrayRecursive(root.getRight(), target);\r\n    }\r\n}"],"names":["ArgumentNullException","constructor","message","this","Error","ArgumentOutOfRangeException","ArgumentException","List","data","count","length","add","item","push","clear","contains","indexOf","exists","predicate","some","find","findAll","foundData","filter","findIndex","startIndex","Count","foundIndex","ix","findLast","foundItem","elem","findLastIndex","forEach","action","d","get","index","insert","splice","lastIndexOf","remove","removeAt","removeAll","preCount","removeRange","removedCount","reverse","set","sort","comparer","e1","e2","toArray","next","iteratorIndex","Symbol","iterator","prototypeAccessors","InvalidOperationException","Queue","dequeue","enqueue","peek","Stack","pop","BinaryTreeNode","rootData","getLeft","left","getRight","right","setLeft","node","setRight","setData","getData","BinaryTree","comparator","v1","v2","root","containsRecursive","insertRecursive","isEmpty","countNodes","countTreeNodes","delete","deleteRecursive","smallestValue","findSmallestValue","findRecursive","search","searchTree","traverseAndMap","mapper","traverseAndMapRecursive","traverseAndMapToArray","direction","array","map","v","traverseAndMorph","morpher","tree","e","morphedItem","target","toInorderArray","toPreorderArray","toPostorderArray","RedBlackNode","parent","color","RED","getColor","getParent","getSibling","isOnLeft","getUncle","hasRedChild","moveDown","p","setParent","setColor","BinarySearchTree","searchNode","deleteNode","u","findReplaceItem","bothBlack","BLACK","swapValues","fixDoubleBlack","getSuccessor","sibling","rightRotate","leftRotate","fixRedRed","grandParent","uncle","swapColors","getRoot","temp","toArrayRecursive"],"mappings":"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"}