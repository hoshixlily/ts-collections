{"version":3,"file":"index.es.js","sources":["../src/exceptions/ArgumentNullException.ts","../src/exceptions/ArgumentOutOfRangeException.ts","../src/exceptions/ArgumentException.ts","../src/list/List.ts","../src/exceptions/InvalidOperationException.ts","../src/queue/Queue.ts","../src/stack/Stack.ts","../src/tree/AbstractTree.ts","../src/tree/TreeNode.ts","../src/tree/BinaryTree.ts","../src/tree/BinarySearchTree.ts"],"sourcesContent":["export class ArgumentNullException extends Error {\r\n    name = \"ArgumentNullException\";\r\n    message = \"object is null.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","export class ArgumentOutOfRangeException extends Error {\r\n    public name: string = \"ArgumentOutOfRangeException\";\r\n    public message: string = \"arrayIndex is out of range.\";\r\n    public constructor(message: string) {\r\n        super();\r\n        this.message = message;\r\n    }\r\n}","export class ArgumentException extends Error {\r\n    public name = \"ArgumentException\";\r\n    public message = \"Invalid argument.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if(message) {\r\n            this.message = message;\r\n        }\r\n    }\r\n}","import { IList } from \"./IList\";\r\nimport { ArgumentNullException } from \"../exceptions/ArgumentNullException\";\r\nimport { ArgumentOutOfRangeException } from \"../exceptions/ArgumentOutOfRangeException\";\r\nimport { ArgumentException } from \"../exceptions/ArgumentException\";\r\n\r\nexport class List<T> implements IList<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    public constructor(data?: T[]){\r\n        if(data) {\r\n            this.data = [...data];\r\n            this.count = this.data.length;\r\n        }\r\n    }\r\n    public add(item: T) {\r\n        this.data.push(item);\r\n        this.count++;\r\n    }\r\n    public clear() {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return  this.indexOf(item) > -1;\r\n    }\r\n    public exists(predicate: (item: T) => boolean): boolean {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        return this.data.some(predicate);\r\n    }\r\n    public find(predicate: (item: T) => boolean): T|null {\r\n        const item = this.data.find(predicate);\r\n        return item || null;\r\n    }\r\n    public findAll(predicate: (item: T) => boolean): List<T> {\r\n        const foundData = this.data.filter(predicate);\r\n        return new List<T>(foundData);\r\n    }\r\n    public findIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        \r\n        startIndex = startIndex || 0;\r\n        count      = count || this.Count-1;\r\n\r\n        if (startIndex! < 0 || startIndex >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        \r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex; ix < startIndex+count; ++ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public findLast(predicate: (item: T) => boolean): T {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        let found = false;\r\n        let foundItem: T = null;\r\n        for (let ix = this.data.length - 1; ix >= 0; --ix) {\r\n            const elem = this.data[ix];\r\n            found = predicate(elem);\r\n            if (found) {\r\n                foundItem = elem;\r\n                break;\r\n            }\r\n        }\r\n        return foundItem;\r\n    }\r\n    public findLastIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        if (startIndex < 0 || startIndex >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        startIndex = startIndex || 0;\r\n        count      = count || this.Count;\r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex+count-1; ix >= startIndex; --ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (!action) {\r\n            throw new ArgumentNullException(\"action is null.\");\r\n        }\r\n        this.data.forEach(d => d ? action(d) : void 0);\r\n    }\r\n    public get(index: number): T {\r\n        if (index == null) {\r\n            throw new ArgumentNullException(\"index is null.\");\r\n        }\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        return this.data[index];\r\n    }\r\n    public indexOf(item: T): number {\r\n        return this.data.findIndex(d => d === item);\r\n    }\r\n    public insert(index: number, item: T) {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data.splice(index, 0, item);\r\n        this.count++;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n    public lastIndexOf(item: T): number {\r\n        return this.data.lastIndexOf(item);\r\n    }\r\n    public remove(item: T): boolean {\r\n        const index = this.findIndex(d => d === item);\r\n        if (index === -1) return false;\r\n        this.removeAt(index);\r\n        return true;\r\n    }\r\n    public removeAll(predicate: (value: T) => boolean): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        const preCount = this.Count;\r\n        this.data = this.data.filter(d => !predicate(d));\r\n        this.count = this.data.length;\r\n        return preCount - this.count;\r\n    }\r\n    public removeAt(index: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data.splice(index, 1);\r\n        this.count--;\r\n    }\r\n    public removeRange(index: number, count: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (index+count > this.Count) {\r\n            throw new ArgumentException(\"index and count do not denote a valid range of elements in the list.\");\r\n        }\r\n        let removedCount = 0;\r\n        while(removedCount < count) {\r\n            this.removeAt(index);\r\n            removedCount++;\r\n        }\r\n    }\r\n    public reverse(): void {\r\n        this.data.reverse();\r\n    }\r\n    public set(index: number, item: T): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data[index] = item;\r\n    }\r\n    public sort(comparer?: (e1: T, e2: T) => number): void {\r\n        if (!comparer) {\r\n            comparer = (e1: T, e2: T) => e1 > e2 ? 1 : -1;\r\n        }\r\n        this.data.sort(comparer);\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n    public get Count() { return this.count; }\r\n}","export class InvalidOperationException extends Error {\r\n    name = \"InvalidOperationException\";\r\n    message = \"Invalid operation.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","import { ICollection } from \"../core/ICollection\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\n\r\nexport class Queue<T> implements ICollection<T>, IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]) {\r\n        if (data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public clear(): void {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.data.findIndex(d => d === item) > -1;\r\n    }\r\n    public dequeue(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        this.count--;\r\n        return item;\r\n    }\r\n    public enqueue(item: T): void {\r\n        this.data.push(item);\r\n        this.count++;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n    public peek(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        return this.data[0];\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n    public get Count() { return this.count; }\r\n}","import { ICollection } from \"../core/ICollection\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\n\r\nexport class Stack<T> implements ICollection<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    public constructor(data?: T[]) {\r\n        if (data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public clear(): void {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.data.findIndex(d => d === item) > -1;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n    public peek(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"stack is empty.\");\r\n        }\r\n        return this.data[0];\r\n    }\r\n    public pop(): T {\r\n        if (this.count === 0) {\r\n            throw new InvalidOperationException(\"stack is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        this.count--;\r\n        return item;\r\n    }\r\n    public push(item: T): void {\r\n        this.data.splice(0, 0, item);\r\n        this.count++;\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n    public get Count() { return this.count; }\r\n}","import { ITree, TraverseType } from \"./ITree\";\r\nimport { INode } from \"./INode\";\r\n\r\nexport abstract class AbstractTree<T> implements ITree<T> {\r\n    protected comparator: Function = null;\r\n    protected root: INode<T>;\r\n    protected constructor(comparator: Function) {\r\n        this.comparator = comparator;\r\n    }\r\n    public clear(): void {\r\n        this.root = null;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.containsRecursive(this.root, item);\r\n    }\r\n    private containsRecursive(root: INode<T>, item: T): boolean {\r\n        if (root == null) return false;\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        return this.comparator(item, root.getData()) < 0\r\n            ? this.containsRecursive(root.getLeft(), item)\r\n            : this.containsRecursive(root.getRight(), item);\r\n    }\r\n    private countTreeNodes(root: INode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    public find(predicate: (item: T) => boolean): T {\r\n        if (this.root == null) return null;\r\n        return this.findRecursive(<INode<T>>this.root, predicate);\r\n    }\r\n    private findRecursive(root: INode<T>, predicate: (item: T) => boolean): T {\r\n        if (root == null) return null;\r\n        if (predicate(root.getData())) return root.getData();\r\n        let foundItem: T = this.findRecursive(root.getLeft(), predicate);\r\n        if (foundItem != null){\r\n            return foundItem;\r\n        }\r\n        return this.findRecursive(root.getRight(), predicate);\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (this.root == null) return;\r\n        this.forEachRecursive(this.root, action);\r\n    }\r\n    private forEachRecursive(root: INode<T>, action: (item: T) => void): void {\r\n        if (root == null) return;\r\n        this.forEachRecursive(root.getLeft(), action);\r\n        action(root.getData());\r\n        this.forEachRecursive(root.getRight(), action);\r\n    }\r\n    public getNodeCount(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    public getRootData(): T {\r\n        return this.root.getData();\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    public toArray(): T[] {\r\n        const target: T[] = [];\r\n        if (this.isEmpty()) return target;\r\n        this.toArrayRecursive(<INode<T>>this.root, target);\r\n        return target;\r\n    }\r\n    private toArrayRecursive(root: INode<T>, target: T[]): void {\r\n        if (root == null) return;\r\n        this.toArrayRecursive(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toArrayRecursive(root.getRight(), target);\r\n    }\r\n    protected toInorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toInorderArray(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toInorderArray(root.getRight(), target);\r\n    }\r\n    protected toPostorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toPostorderArray(root.getLeft(), target);\r\n        this.toPostorderArray(root.getRight(), target);\r\n        target.push(root.getData());\r\n    }\r\n    protected toPreorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        target.push(root.getData());\r\n        this.toPreorderArray(root.getLeft(), target);\r\n        this.toPreorderArray(root.getRight(), target);\r\n    }\r\n    public traverseAndMapToArray<R>(mapper: (item: T) => R, direction: TraverseType = \"INORDER\"): R[] {\r\n        let array: T[] = [];\r\n        switch(direction) {\r\n            case \"INORDER\":\r\n                this.toInorderArray(this.root, array);\r\n                break;\r\n            case \"PREORDER\":\r\n                this.toPreorderArray(this.root, array);\r\n                break;\r\n            case \"POSTORDER\":\r\n                this.toPostorderArray(this.root, array);\r\n                break;\r\n        }\r\n        return array.map(v => mapper(v));\r\n    }\r\n    public traverseAndMorph<R>(tree: ITree<R>, morpher: (item: T) => R): ITree<R> {\r\n        this.traverseAndMorphRecursive(this.root, morpher, tree);\r\n        return tree;\r\n    }\r\n    private traverseAndMorphRecursive<R>(root: INode<T>, morpher: (item: T) => R, tree: ITree<R>): void {\r\n        if (root == null) return;\r\n        tree.insert(morpher(root.getData()));\r\n        this.traverseAndMorphRecursive(root.getLeft(), morpher, tree);\r\n        this.traverseAndMorphRecursive(root.getRight(), morpher, tree);\r\n    }\r\n\r\n    public abstract delete(item: T): void;\r\n    public abstract insert(item: T): void;\r\n    public abstract search(item: T): boolean;\r\n}","import { INode } from \"./INode\";\r\n\r\nexport class TreeNode<T> implements INode<T> {\r\n    private data: T;\r\n    private left: INode<T>;\r\n    private right: INode<T>;\r\n    public constructor(data?: T) {\r\n        this.data = data || null;\r\n    }\r\n    public getData(): T {\r\n        return this.data;\r\n    }\r\n    public getLeft(): INode<T> {\r\n        return this.left;\r\n    }\r\n    public getRight(): INode<T> {\r\n        return this.right;\r\n    }\r\n    public setData(data: T): void {\r\n        this.data = data;\r\n    }\r\n    public setLeft(node: INode<T>): void {\r\n        this.left = node;\r\n    }\r\n    public setRight(node: INode<T>): void {\r\n        this.right = node;\r\n    }\r\n}","import { AbstractTree } from \"./AbstractTree\";\r\nimport { TreeNode } from \"./TreeNode\";\r\nexport class BinaryTree<T> extends AbstractTree<T> {\r\n    public constructor(comparator: Function) {\r\n        super(comparator);\r\n        this.root = null;\r\n    }\r\n    public delete(item: T): void {\r\n        this.root = this.deleteRecursive(this.root as TreeNode<T>, item);\r\n    }\r\n    private deleteRecursive(root: TreeNode<T>, item: T): TreeNode<T> {\r\n        if (root == null) return null;\r\n        if (this.comparator(item, root.getData()) === 0) {\r\n            if (root.getLeft() == null && root.getRight() == null) {\r\n                return null;\r\n            }\r\n            if (root.getRight() == null) {\r\n                return root.getLeft() as TreeNode<T>;\r\n            }\r\n            if (root.getLeft() == null) {\r\n                return root.getRight() as TreeNode<T>;\r\n            }\r\n            const smallestValue = this.findSmallestValue(root.getRight() as TreeNode<T>);\r\n            root.setData(smallestValue);\r\n            root.setRight(this.deleteRecursive(root.getRight() as TreeNode<T>, smallestValue));\r\n            return root;\r\n        }\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.deleteRecursive(root.getLeft() as TreeNode<T>, item));\r\n            return root;\r\n        }\r\n        root.setRight(this.deleteRecursive(root.getRight() as TreeNode<T>, item));\r\n        return root;\r\n    }\r\n    private findSmallestValue(root: TreeNode<T>): T {\r\n        return root.getLeft() == null ? root.getData() : this.findSmallestValue(root.getLeft() as TreeNode<T>);\r\n    }\r\n    public insert(item: T): void {\r\n        this.root = this.insertRecursive(this.root as TreeNode<T>, item);\r\n    }\r\n    private insertRecursive(root: TreeNode<T>, item: T): TreeNode<T> {\r\n        if (root == null) return new TreeNode<T>(item);\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.insertRecursive(root.getLeft() as TreeNode<T>, item));\r\n        } else if (this.comparator(item, root.getData()) > 0) {\r\n            root.setRight(this.insertRecursive(root.getRight() as TreeNode<T>, item));\r\n        } else {\r\n            return root;\r\n        }\r\n        return root;\r\n    }\r\n    public search(item: T): boolean {\r\n       return this.searchTree(this.root as TreeNode<T>, item);\r\n    }\r\n    private searchTree(root: TreeNode<T>, item: T): boolean {\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        if (root.getLeft() != null) {\r\n            if (this.searchTree(root.getLeft() as TreeNode<T>, item)) return true;\r\n        }\r\n        if (root.getRight() != null) {\r\n            if (this.searchTree(root.getRight() as TreeNode<T>, item)) return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    \r\n}","import { AbstractTree } from \"./AbstractTree\";\r\nimport { TreeNode } from \"./TreeNode\";\r\n\r\n// Algorithm taken from https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/\r\nclass RedBlackNode<T> extends TreeNode<T> {\r\n    public static readonly RED   = 0;\r\n    public static readonly BLACK = 1;\r\n    private parent: RedBlackNode<T>;\r\n    private color: number;\r\n    public constructor(data: T) {\r\n        super(data);\r\n        this.setLeft(null);\r\n        this.setRight(null);\r\n        this.parent = null;\r\n        this.color = RedBlackNode.RED;\r\n    }\r\n    public getColor(): number { return this.color; }\r\n    public getParent(): RedBlackNode<T> { return this.parent; }\r\n    public getSibling(): RedBlackNode<T> {\r\n        if (this.parent == null) return null;\r\n        if (this.isOnLeft()) return this.parent.getRight() as RedBlackNode<T>;\r\n        return this.parent.getLeft() as RedBlackNode<T>;\r\n    }\r\n    public getUncle(): RedBlackNode<T> {\r\n        if (this.parent == null || this.parent.getParent() == null){\r\n            return null;\r\n        }\r\n        if (this.parent.isOnLeft()){\r\n            return this.parent.getParent().getRight() as RedBlackNode<T>;\r\n        }\r\n        return this.parent.getParent().getLeft() as RedBlackNode<T>;\r\n    }\r\n    public hasRedChild(): boolean {\r\n        return (this.getLeft() != null && (this.getLeft() as RedBlackNode<T>).getColor() === RedBlackNode.RED)\r\n            || (this.getRight() != null && (this.getRight() as RedBlackNode<T>).getColor() === RedBlackNode.RED);\r\n    }\r\n    public isOnLeft(): boolean {\r\n        return this.parent.getLeft() === this;\r\n    }\r\n    public moveDown(p: RedBlackNode<T>): void { //p: parentnode\r\n        if (this.parent != null) {\r\n            if (this.isOnLeft()) {\r\n                this.parent.setLeft(p);\r\n            } else {\r\n                this.parent.setRight(p);\r\n            }\r\n        }\r\n        p.setParent(this.parent);\r\n        this.parent = p;\r\n    }\r\n    public setColor(color: number): void { this.color = color; }\r\n    public setParent(parent: RedBlackNode<T>): void { this.parent = parent; }\r\n}\r\n\r\nexport class BinarySearchTree<T> extends AbstractTree<T> {\r\n    public constructor(comparator: Function){\r\n        super(comparator);\r\n        this.root = null;\r\n    }\r\n    /**\r\n     * Removes an item from the tree.\r\n     * @param item The item to be removed from tree.\r\n     */\r\n    public delete(item: T): void {\r\n        if (this.root == null) return;\r\n        let v: RedBlackNode<T> = this.searchNode(item);\r\n        if (v.getData() !== item) {\r\n            return;\r\n        }\r\n        this.deleteNode(v);\r\n    }\r\n    private deleteNode(v: RedBlackNode<T>): void {\r\n        let u: RedBlackNode<T> = this.findReplaceItem(v);\r\n        const bothBlack = ((u == null || u.getColor() === RedBlackNode.BLACK) && v.getColor() === RedBlackNode.BLACK);\r\n        let parent: RedBlackNode<T> = v.getParent();\r\n        if (u === null) {\r\n            if (v === this.root) {\r\n                this.root = null;\r\n            } else {\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(v);\r\n                } else {\r\n                    if (v.getSibling() != null) {\r\n                        v.getSibling().setColor(RedBlackNode.RED);\r\n                    }\r\n                }\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(null);\r\n                } else {\r\n                    parent.setRight(null);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (v.getLeft() == null || v.getRight() == null) {\r\n            if (v === this.root) {\r\n                v.setData(u.getData());\r\n                v.setLeft(null);\r\n                v.setRight(null);\r\n            } else {\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(u);\r\n                } else {\r\n                    parent.setRight(u);\r\n                }\r\n                u.setParent(parent);\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(u);\r\n                } else {\r\n                    u.setColor(RedBlackNode.BLACK);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        this.swapValues(u, v);\r\n        this.deleteNode(u);\r\n    }\r\n    private findReplaceItem(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        if (node.getLeft() != null && node.getRight() != null) {\r\n            return this.getSuccessor(node.getRight() as RedBlackNode<T>);\r\n        }\r\n        if (node.getLeft() == null && node.getRight() == null) {\r\n            return null;\r\n        }\r\n        if (node.getLeft() != null){\r\n            return node.getLeft() as RedBlackNode<T>;\r\n        }\r\n        return node.getRight() as RedBlackNode<T>;\r\n    }\r\n    private fixDoubleBlack(node: RedBlackNode<T>): void {\r\n        if (node === this.root) return;\r\n        let sibling = node.getSibling();\r\n        let parent  = node.getParent();\r\n        if (sibling == null) {\r\n            this.fixDoubleBlack(parent);\r\n        } else {\r\n            if (sibling.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.RED);\r\n                sibling.setColor(RedBlackNode.BLACK);\r\n                if (sibling.isOnLeft()) {\r\n                    this.rightRotate(parent);\r\n                } else {\r\n                    this.leftRotate(parent);\r\n                }\r\n                this.fixDoubleBlack(node);\r\n            } else {\r\n                if (sibling.hasRedChild()) {\r\n                    if ((sibling.getLeft() as RedBlackNode<T>) != null && (sibling.getLeft() as RedBlackNode<T>).getColor() === RedBlackNode.RED) {\r\n                        if (sibling.isOnLeft()) {\r\n                            (sibling.getLeft() as RedBlackNode<T>).setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            (sibling.getLeft() as RedBlackNode<T>).setColor(parent.getColor());\r\n                            this.rightRotate(sibling);\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    } else {\r\n                        if (sibling.isOnLeft()) {\r\n                            (sibling.getRight() as RedBlackNode<T>).setColor(parent.getColor());\r\n                            this.leftRotate(sibling);\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            (sibling.getRight() as RedBlackNode<T>).setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    }\r\n                    parent.setColor(RedBlackNode.BLACK);\r\n                } else {\r\n                    sibling.setColor(RedBlackNode.RED);\r\n                    if (parent.getColor() === RedBlackNode.BLACK) {\r\n                        this.fixDoubleBlack(parent);\r\n                    } else {\r\n                        parent.setColor(RedBlackNode.BLACK);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private fixRedRed(node: RedBlackNode<T>): void {\r\n        if (node === this.root){\r\n            node.setColor(RedBlackNode.BLACK);\r\n            return;\r\n        }\r\n        let parent: RedBlackNode<T> = node.getParent();\r\n        let grandParent: RedBlackNode<T> = parent.getParent();\r\n        let uncle: RedBlackNode<T> = node.getUncle();\r\n        if (parent.getColor() !== RedBlackNode.BLACK){\r\n            if (uncle != null && uncle.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.BLACK);\r\n                uncle.setColor(RedBlackNode.BLACK);\r\n                grandParent.setColor(RedBlackNode.RED);\r\n                this.fixRedRed(grandParent);\r\n            } else {\r\n                if (parent.isOnLeft()) {\r\n                    if (node.isOnLeft()) {\r\n                        this.swapColors(parent, grandParent);\r\n                    } else {\r\n                        this.leftRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    }\r\n                    this.rightRotate(grandParent);\r\n                } else {\r\n                    if (node.isOnLeft()) {\r\n                        this.rightRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    } else {\r\n                        this.swapColors(parent, grandParent);\r\n                    }\r\n                    this.leftRotate(grandParent);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private getSuccessor(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        let temp = node;\r\n        while (temp.getLeft() != null){\r\n            temp = temp.getLeft() as RedBlackNode<T>;\r\n        }\r\n        return temp;\r\n    }\r\n    /**\r\n     * Inserts an item to the tree.\r\n     * @param item Item to be inserted.\r\n     */\r\n    public insert(item: T): void {\r\n        const node = new RedBlackNode<T>(item);\r\n        if (this.root == null) {\r\n            node.setColor(RedBlackNode.BLACK);\r\n            this.root = node;\r\n        } else {\r\n            const temp: RedBlackNode<T> = this.searchNode(item);\r\n            if (temp.getData() === item) {\r\n                return;\r\n            }\r\n            node.setParent(temp);\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                temp.setLeft(node);\r\n            } else {\r\n                temp.setRight(node);\r\n            }\r\n            this.fixRedRed(node);\r\n        }\r\n    }\r\n    private leftRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getRight();\r\n        if (node === this.root) {\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p as RedBlackNode<T>);\r\n        node.setRight(p.getLeft() as RedBlackNode<T>);\r\n        if (p.getLeft() != null) {\r\n            (p.getLeft() as RedBlackNode<T>).setParent(node);\r\n        }\r\n        p.setLeft(node);\r\n    }\r\n    private rightRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getLeft();\r\n        if (node === this.root){\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p as RedBlackNode<T>);\r\n        node.setLeft(p.getRight());\r\n        if (p.getRight() != null) {\r\n            (p.getRight() as RedBlackNode<T>).setParent(node);\r\n        }\r\n        p.setRight(node);\r\n    }\r\n    public search(item: T): boolean {\r\n        const node = this.searchNode(item);\r\n        return this.comparator(node.getData(), item) === 0;\r\n    }\r\n    private searchNode(item: T): RedBlackNode<T> {\r\n        let temp: RedBlackNode<T> = this.root as RedBlackNode<T>;\r\n        while (temp != null) {\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                if (temp.getLeft() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getLeft() as RedBlackNode<T>;\r\n                }\r\n            } else if (item === temp.getData()) {\r\n                break;\r\n            } else {\r\n                if (temp.getRight() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getRight() as RedBlackNode<T>;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n    private swapColors(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getColor();\r\n        u.setColor(v.getColor());\r\n        v.setColor(temp);\r\n    }\r\n    private swapValues(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getData();\r\n        u.setData(v.getData());\r\n        v.setData(temp);\r\n    }\r\n}"],"names":["ArgumentNullException","constructor","message","this","Error","ArgumentOutOfRangeException","ArgumentException","List","data","count","length","add","item","push","clear","contains","indexOf","exists","predicate","some","find","findAll","foundData","filter","findIndex","startIndex","Count","foundIndex","ix","findLast","foundItem","elem","findLastIndex","forEach","action","d","get","index","insert","splice","isEmpty","lastIndexOf","remove","removeAt","removeAll","preCount","removeRange","removedCount","reverse","set","sort","comparer","e1","e2","toArray","prototypeAccessors","InvalidOperationException","Queue","dequeue","enqueue","peek","next","iteratorIndex","Symbol","iterator","Stack","pop","AbstractTree","comparator","root","containsRecursive","getData","getLeft","getRight","countTreeNodes","findRecursive","forEachRecursive","getNodeCount","getRootData","target","toArrayRecursive","toInorderArray","toPostorderArray","toPreorderArray","traverseAndMapToArray","mapper","direction","array","map","v","traverseAndMorph","tree","morpher","traverseAndMorphRecursive","TreeNode","left","right","setData","setLeft","node","setRight","BinaryTree","delete","deleteRecursive","smallestValue","findSmallestValue","insertRecursive","search","searchTree","RedBlackNode","parent","color","RED","getColor","getParent","getSibling","isOnLeft","getUncle","hasRedChild","moveDown","p","setParent","setColor","BinarySearchTree","searchNode","deleteNode","u","findReplaceItem","bothBlack","BLACK","swapValues","fixDoubleBlack","getSuccessor","sibling","rightRotate","leftRotate","fixRedRed","grandParent","uncle","swapColors","temp"],"mappings":"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"}