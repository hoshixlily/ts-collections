{"version":3,"file":"index.es.js","sources":["../src/exceptions/ArgumentNullException.ts","../src/exceptions/ArgumentOutOfRangeException.ts","../src/exceptions/ArgumentException.ts","../src/list/List.ts","../src/exceptions/InvalidOperationException.ts","../src/queue/Queue.ts","../src/stack/Stack.ts","../src/tree/BinaryTree.ts","../src/tree/BinarySearchTree.ts"],"sourcesContent":["export class ArgumentNullException extends Error {\r\n    name = \"ArgumentNullException\";\r\n    message = \"object is null.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","export class ArgumentOutOfRangeException extends Error {\r\n    public name: string = \"ArgumentOutOfRangeException\";\r\n    public message: string = \"arrayIndex is out of range.\";\r\n    public constructor(message: string) {\r\n        super();\r\n        this.message = message;\r\n    }\r\n}","export class ArgumentException extends Error {\r\n    public name = \"ArgumentException\";\r\n    public message = \"Invalid argument.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if(message) {\r\n            this.message = message;\r\n        }\r\n    }\r\n}","import { IList } from \"./IList\";\r\nimport { ArgumentNullException } from \"../exceptions/ArgumentNullException\";\r\nimport { ArgumentOutOfRangeException } from \"../exceptions/ArgumentOutOfRangeException\";\r\nimport { ArgumentException } from \"../exceptions/ArgumentException\";\r\n\r\nexport class List<T> implements IList<T>, IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    // private enumerator: IEnumerator<T> = null;\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]){\r\n        if(data) {\r\n            this.data = [...data];\r\n            this.count = this.data.length;\r\n        }\r\n    }\r\n    public add(item: T) {\r\n        this.data.push(item);\r\n        this.count++;\r\n    }\r\n    public clear() {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return  this.indexOf(item) > -1;\r\n    }\r\n    public exists(predicate: (item: T) => boolean): boolean {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        return this.data.some(predicate);\r\n    }\r\n    public find(predicate: (item: T) => boolean): T|null {\r\n        const item = this.data.find(predicate);\r\n        return item || null;\r\n    }\r\n    public findAll(predicate: (item: T) => boolean): List<T> {\r\n        const foundData = this.data.filter(predicate);\r\n        return new List<T>(foundData);\r\n    }\r\n    public findIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        \r\n        startIndex = startIndex || 0;\r\n        count      = count || this.Count-1;\r\n\r\n        if (startIndex! < 0 || startIndex >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        \r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex; ix < startIndex+count; ++ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public findLast(predicate: (item: T) => boolean): T {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        let found = false;\r\n        let foundItem: T = null;\r\n        for (let ix = this.data.length - 1; ix >= 0; --ix) {\r\n            const elem = this.data[ix];\r\n            found = predicate(elem);\r\n            if (found) {\r\n                foundItem = elem;\r\n                break;\r\n            }\r\n        }\r\n        return foundItem;\r\n    }\r\n    public findLastIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        if (startIndex < 0 || startIndex >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        startIndex = startIndex || 0;\r\n        count      = count || this.Count;\r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex+count-1; ix >= startIndex; --ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (!action) {\r\n            throw new ArgumentNullException(\"action is null.\");\r\n        }\r\n        this.data.forEach(d => d ? action(d) : void 0);\r\n    }\r\n    public get(index: number): T {\r\n        if (index == null) {\r\n            throw new ArgumentNullException(\"index is null.\");\r\n        }\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        return this.data[index];\r\n    }\r\n    public indexOf(item: T): number {\r\n        return this.data.findIndex(d => d === item);\r\n    }\r\n    public insert(index: number, item: T) {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data.splice(index, 0, item);\r\n        this.count++;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n    public lastIndexOf(item: T): number {\r\n        return this.data.lastIndexOf(item);\r\n    }\r\n    public remove(item: T): boolean {\r\n        const index = this.findIndex(d => d === item);\r\n        if (index === -1) return false;\r\n        this.removeAt(index);\r\n        return true;\r\n    }\r\n    public removeAll(predicate: (value: T) => boolean): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        const preCount = this.Count;\r\n        this.data = this.data.filter(d => !predicate(d));\r\n        this.count = this.data.length;\r\n        return preCount - this.count;\r\n    }\r\n    public removeAt(index: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data.splice(index, 1);\r\n        this.count--;\r\n    }\r\n    public removeRange(index: number, count: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (index+count > this.Count) {\r\n            throw new ArgumentException(\"index and count do not denote a valid range of elements in the list.\");\r\n        }\r\n        let removedCount = 0;\r\n        while(removedCount < count) {\r\n            this.removeAt(index);\r\n            removedCount++;\r\n        }\r\n    }\r\n    public reverse(): void {\r\n        this.data.reverse();\r\n    }\r\n    public set(index: number, item: T): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data[index] = item;\r\n    }\r\n    public sort(comparer?: (e1: T, e2: T) => number): void {\r\n        if (!comparer) {\r\n            comparer = (e1: T, e2: T) => e1 > e2 ? 1 : -1;\r\n        }\r\n        this.data.sort(comparer);\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n    public get Count() { return this.count; }\r\n}","export class InvalidOperationException extends Error {\r\n    name = \"InvalidOperationException\";\r\n    message = \"Invalid operation.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","import { ICollection } from \"../core/ICollection\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\n\r\nexport class Queue<T> implements ICollection<T>, IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]) {\r\n        if (data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public clear(): void {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.data.findIndex(d => d === item) > -1;\r\n    }\r\n    public dequeue(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        this.count--;\r\n        return item;\r\n    }\r\n    public enqueue(item: T): void {\r\n        this.data.push(item);\r\n        this.count++;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n    public peek(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        return this.data[0];\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n    public get Count() { return this.count; }\r\n}","import { ICollection } from \"../core/ICollection\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\n\r\nexport class Stack<T> implements ICollection<T>, IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]) {\r\n        if (data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public clear(): void {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.data.findIndex(d => d === item) > -1;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n    public peek(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"stack is empty.\");\r\n        }\r\n        return this.data[0];\r\n    }\r\n    public pop(): T {\r\n        if (this.count === 0) {\r\n            throw new InvalidOperationException(\"stack is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        this.count--;\r\n        return item;\r\n    }\r\n    public push(item: T): void {\r\n        this.data.splice(0, 0, item);\r\n        this.count++;\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n    public get Count() { return this.count; }\r\n}","import { ITree } from \"./ITree\";\r\n\r\nexport declare type TraverseType = \"INORDER\" | \"PREORDER\" | \"POSTORDER\";\r\nclass BinaryTreeNode<T extends any> {\r\n    private left: BinaryTreeNode<T>;\r\n    private right: BinaryTreeNode<T>;\r\n    private data: T;\r\n    public constructor(rootData?: T) {\r\n        if (rootData) this.data = rootData;\r\n    }\r\n    public getLeft(): BinaryTreeNode<T> {\r\n        return this.left;\r\n    }\r\n    public getRight(): BinaryTreeNode<T> {\r\n        return this.right;\r\n    }\r\n    public setLeft(node: BinaryTreeNode<T>): void {\r\n        this.left = node;\r\n    }\r\n    public setRight(node: BinaryTreeNode<T>): void {\r\n        this.right = node;\r\n    }\r\n    public setData(data: T): void {\r\n        this.data = data;\r\n    }\r\n    public getData(): T {\r\n        return this.data;\r\n    }\r\n}\r\nexport class BinaryTree<T> implements ITree<T> {\r\n    private comparator: Function = null;\r\n    private root: BinaryTreeNode<T>;\r\n    public constructor(comparator: Function) {\r\n        this.root = null;\r\n        this.comparator = comparator;\r\n    }\r\n    public clear(): void {\r\n        this.root = null;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.containsRecursive(this.root, item);\r\n    }\r\n    private containsRecursive(root: BinaryTreeNode<T>, item: T): boolean {\r\n        if (root == null) return false;\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        return this.comparator(item, root.getData()) < 0\r\n            ? this.containsRecursive(root.getLeft(), item)\r\n            : this.containsRecursive(root.getRight(), item);\r\n    }\r\n    public insert(item: T): void {\r\n        this.root = this.insertRecursive(this.root, item);\r\n    }\r\n    private insertRecursive(root: BinaryTreeNode<T>, item: T): BinaryTreeNode<T> {\r\n        if (root == null) return new BinaryTreeNode<T>(item);\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.insertRecursive(root.getLeft(), item));\r\n        } else if (this.comparator(item, root.getData()) > 0) {\r\n            root.setRight(this.insertRecursive(root.getRight(), item));\r\n        } else {\r\n            return root;\r\n        }\r\n        return root;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    public getNodeCount(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    private countTreeNodes(root: BinaryTreeNode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    public delete(item: T): void {\r\n        this.root = this.deleteRecursive(this.root, item);\r\n    }\r\n    private deleteRecursive(root: BinaryTreeNode<T>, item: T): BinaryTreeNode<T> {\r\n        if (root == null) return null;\r\n        if (this.comparator(item, root.getData()) === 0) {\r\n            if (root.getLeft() == null && root.getRight() == null) {\r\n                return null;\r\n            }\r\n            if (root.getRight() == null) {\r\n                return root.getLeft();\r\n            }\r\n            if (root.getLeft() == null) {\r\n                return root.getRight();\r\n            }\r\n            const smallestValue = this.findSmallestValue(root.getRight());\r\n            root.setData(smallestValue);\r\n            root.setRight(this.deleteRecursive(root.getRight(), smallestValue));\r\n            return root;\r\n        }\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.deleteRecursive(root.getLeft(), item));\r\n            return root;\r\n        }\r\n        root.setRight(this.deleteRecursive(root.getRight(), item));\r\n        return root;\r\n    }\r\n    public find(predicate: (item: T) => boolean): T {\r\n        if (this.root == null) return null;\r\n        return this.findRecursive(this.root, predicate);\r\n    }\r\n    private findRecursive(root: BinaryTreeNode<T>, predicate: (item: T) => boolean): T {\r\n        if (root == null) return null;\r\n        if (predicate(root.getData())) return root.getData();\r\n        let foundItem: T = this.findRecursive(root.getLeft(), predicate);\r\n        if (foundItem != null){\r\n            return foundItem;\r\n        }\r\n        return this.findRecursive(root.getRight(), predicate);\r\n    }\r\n    private findSmallestValue(root: BinaryTreeNode<T>): T {\r\n        return root.getLeft() == null ? root.getData() : this.findSmallestValue(root.getLeft());\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (this.root == null) return;\r\n        this.forEachRecursive(this.root, action);\r\n    }\r\n    private forEachRecursive(root: BinaryTreeNode<T>, action: (item: T) => void): void {\r\n        if (root == null) return;\r\n        this.forEachRecursive(root.getLeft(), action);\r\n        action(root.getData());\r\n        this.forEachRecursive(root.getRight(), action);\r\n    }\r\n    public getRootData(): T {\r\n        return this.root == null ? null : this.root.getData();\r\n    }\r\n    public search(item: T): boolean {\r\n       return this.searchTree(this.root, item);\r\n    }\r\n    private searchTree(root: BinaryTreeNode<T>, item: T): boolean {\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        if (root.getLeft() != null) {\r\n            if (this.searchTree(root.getLeft(), item)) return true;\r\n        }\r\n        if (root.getRight() != null) {\r\n            if (this.searchTree(root.getRight(), item)) return true;\r\n        }\r\n        return false;\r\n    }\r\n    public traverseAndMapToArray<R>(mapper: (item: T) => R, direction: TraverseType = \"INORDER\"): R[] {\r\n        let array: T[] = [];\r\n        switch(direction) {\r\n            case \"INORDER\":\r\n                array = this.toArray(\"INORDER\");\r\n                break;\r\n            case \"PREORDER\":\r\n                array = this.toArray(\"PREORDER\");\r\n                break;\r\n            case \"POSTORDER\":\r\n                array = this.toArray(\"POSTORDER\");\r\n                break;\r\n        }\r\n        return array.map(v => mapper(v));\r\n    }\r\n    public traverseAndMorph<R>(morpher: (item: T) => R, comparator?: (i1: R, i2: R) => number): BinaryTree<R> {\r\n        const compare  = comparator || this.comparator;\r\n        const tree     = new BinaryTree<R>(compare);\r\n        let array: T[] = [];\r\n        array = this.toArray(\"PREORDER\");\r\n        array.forEach(e => {\r\n            const morphedItem = morpher(e);\r\n            tree.insert(morphedItem);\r\n        });\r\n        return tree;\r\n    }\r\n    public toArray(direction: TraverseType = \"INORDER\"): T[] {\r\n        const target: T[] = [];\r\n        switch (direction) {\r\n            case \"INORDER\":\r\n                this.toInorderArray(this.root, target);\r\n                return target;\r\n            case \"PREORDER\":\r\n                this.toPreorderArray(this.root, target);\r\n                return target;\r\n            case \"POSTORDER\":\r\n                this.toPostorderArray(this.root, target);\r\n                return target;\r\n            default:\r\n                this.toInorderArray(this.root, target);\r\n                return target;\r\n        }\r\n    }\r\n    private toInorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toInorderArray(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toInorderArray(root.getRight(), target);\r\n    }\r\n    private toPostorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toPostorderArray(root.getLeft(), target);\r\n        this.toPostorderArray(root.getRight(), target);\r\n        target.push(root.getData());\r\n    }\r\n    private toPreorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        target.push(root.getData());\r\n        this.toPreorderArray(root.getLeft(), target);\r\n        this.toPreorderArray(root.getRight(), target);\r\n    }\r\n}","import { ITree } from \"./ITree\";\r\n\r\n// Algorithm taken from https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/\r\nclass RedBlackNode<T> {\r\n    public static readonly RED   = 0;\r\n    public static readonly BLACK = 1;\r\n    private data: T;\r\n    private left: RedBlackNode<T>;\r\n    private parent: RedBlackNode<T>;\r\n    private right: RedBlackNode<T>;\r\n    private color: number;\r\n    public constructor(data: T) {\r\n        this.parent = this.left = this.right = null;\r\n        this.color = RedBlackNode.RED;\r\n        this.data  = data;\r\n    }\r\n    public getData(): T { return this.data; }\r\n    public getColor(): number { return this.color; }\r\n    public getLeft(): RedBlackNode<T> { return this.left; }\r\n    public getParent(): RedBlackNode<T> { return this.parent; }\r\n    public getRight(): RedBlackNode<T> { return this.right; }\r\n    public getSibling(): RedBlackNode<T> {\r\n        if (this.parent == null) return null;\r\n        if (this.isOnLeft()) return this.parent.getRight();\r\n        return this.parent.getLeft();\r\n    }\r\n    public getUncle(): RedBlackNode<T> {\r\n        if (this.parent == null || this.parent.getParent() == null){\r\n            return null;\r\n        }\r\n        if (this.parent.isOnLeft()){\r\n            return this.parent.getParent().getRight();\r\n        }\r\n        return this.parent.getParent().getLeft();\r\n    }\r\n    public hasRedChild(): boolean {\r\n        return (this.left != null && this.left.color === RedBlackNode.RED)\r\n            || (this.right != null && this.right.color === RedBlackNode.RED);\r\n    }\r\n    public isOnLeft(): boolean {\r\n        return this.parent.getLeft() === this;\r\n    }\r\n    public moveDown(p: RedBlackNode<T>): void { //p: parentnode\r\n        if (this.parent != null) {\r\n            if (this.isOnLeft()) {\r\n                this.parent.setLeft(p);\r\n            } else {\r\n                this.parent.setRight(p);\r\n            }\r\n        }\r\n        p.setParent(this.parent);\r\n        this.parent = p;\r\n    }\r\n    public setColor(color: number): void { this.color = color; }\r\n    public setData(data: T): void { this.data = data; }\r\n    public setLeft(left: RedBlackNode<T>): void { this.left = left; }\r\n    public setParent(parent: RedBlackNode<T>): void { this.parent = parent; }\r\n    public setRight(right: RedBlackNode<T>): void { this.right = right; }\r\n}\r\n\r\nexport class BinarySearchTree<T> implements ITree<T> {\r\n    private root: RedBlackNode<T>;\r\n    private comparator: Function = (v1:T|any, v2:T|any) => v1 - v2;\r\n    public constructor(comparator?: Function){\r\n        if (comparator) this.comparator = comparator;\r\n        this.root = null;\r\n    }\r\n    public clear(): void {\r\n        this.root = null;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.containsRecursive(this.root, item);\r\n    }\r\n    private containsRecursive(root: RedBlackNode<T>, item: T): boolean {\r\n        if (root == null) return false;\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        return this.comparator(item, root.getData()) < 0\r\n            ? this.containsRecursive(root.getLeft(), item)\r\n            : this.containsRecursive(root.getRight(), item);\r\n    }\r\n    /**\r\n     * Returns the number of nodes in the tree.\r\n     */\r\n    private countTreeNodes(root: RedBlackNode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    /**\r\n     * Removes an item from the tree.\r\n     * @param item The item to be removed from tree.\r\n     */\r\n    public delete(item: T): void {\r\n        if (this.root == null) return;\r\n        let v: RedBlackNode<T> = this.searchNode(item);\r\n        if (v.getData() !== item) {\r\n            return;\r\n        }\r\n        this.deleteNode(v);\r\n    }\r\n    private deleteNode(v: RedBlackNode<T>): void {\r\n        let u: RedBlackNode<T> = this.findReplaceItem(v);\r\n        const bothBlack = ((u == null || u.getColor() === RedBlackNode.BLACK) && v.getColor() === RedBlackNode.BLACK);\r\n        let parent: RedBlackNode<T> = v.getParent();\r\n        if (u === null) {\r\n            if (v === this.root) {\r\n                this.root = null;\r\n            } else {\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(v);\r\n                } else {\r\n                    if (v.getSibling() != null) {\r\n                        v.getSibling().setColor(RedBlackNode.RED);\r\n                    }\r\n                }\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(null);\r\n                } else {\r\n                    parent.setRight(null);\r\n                }\r\n            }\r\n            // v = null;\r\n            return;\r\n        }\r\n        if (v.getLeft() == null || v.getRight() == null) {\r\n            if (v === this.root) {\r\n                v.setData(u.getData());\r\n                v.setLeft(null);\r\n                v.setRight(null);\r\n                // u = null;\r\n            } else {\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(u);\r\n                } else {\r\n                    parent.setRight(u);\r\n                }\r\n                // v = null;\r\n                u.setParent(parent);\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(u);\r\n                } else {\r\n                    u.setColor(RedBlackNode.BLACK);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        this.swapValues(u, v);\r\n        this.deleteNode(u);\r\n    }\r\n    public find(predicate: (item: T) => boolean): T {\r\n        if (this.root == null) return null;\r\n        return this.findRecursive(this.root, predicate);\r\n    }\r\n    private findRecursive(root: RedBlackNode<T>, predicate: (item: T) => boolean): T {\r\n        if (root == null) return null;\r\n        if (predicate(root.getData())) return root.getData();\r\n        let foundItem: T = this.findRecursive(root.getLeft(), predicate);\r\n        if (foundItem != null){\r\n            return foundItem;\r\n        }\r\n        return this.findRecursive(root.getRight(), predicate);\r\n    }\r\n    private findReplaceItem(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        if (node.getLeft() != null && node.getRight() != null) {\r\n            return this.getSuccessor(node.getRight());\r\n        }\r\n        if (node.getLeft() == null && node.getRight() == null) {\r\n            return null;\r\n        }\r\n        if (node.getLeft() != null){\r\n            return node.getLeft();\r\n        }\r\n        return node.getRight();\r\n    }\r\n    private fixDoubleBlack(node: RedBlackNode<T>): void {\r\n        if (node === this.root) return;\r\n        let sibling = node.getSibling();\r\n        let parent  = node.getParent();\r\n        if (sibling == null) {\r\n            this.fixDoubleBlack(parent);\r\n        } else {\r\n            if (sibling.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.RED);\r\n                sibling.setColor(RedBlackNode.BLACK);\r\n                if (sibling.isOnLeft()) {\r\n                    this.rightRotate(parent);\r\n                } else {\r\n                    this.leftRotate(parent);\r\n                }\r\n                this.fixDoubleBlack(node);\r\n            } else {\r\n                if (sibling.hasRedChild()) {\r\n                    if (sibling.getLeft() != null && sibling.getLeft().getColor() === RedBlackNode.RED) {\r\n                        if (sibling.isOnLeft()) {\r\n                            sibling.getLeft().setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            sibling.getLeft().setColor(parent.getColor());\r\n                            this.rightRotate(sibling);\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    } else {\r\n                        if (sibling.isOnLeft()) {\r\n                            sibling.getRight().setColor(parent.getColor());\r\n                            this.leftRotate(sibling);\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            sibling.getRight().setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    }\r\n                    parent.setColor(RedBlackNode.BLACK);\r\n                } else {\r\n                    sibling.setColor(RedBlackNode.RED);\r\n                    if (parent.getColor() === RedBlackNode.BLACK) {\r\n                        this.fixDoubleBlack(parent);\r\n                    } else {\r\n                        parent.setColor(RedBlackNode.BLACK);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private fixRedRed(node: RedBlackNode<T>): void {\r\n        if (node === this.root){\r\n            node.setColor(RedBlackNode.BLACK);\r\n            return;\r\n        }\r\n        let parent: RedBlackNode<T> = node.getParent();\r\n        let grandParent: RedBlackNode<T> = parent.getParent();\r\n        let uncle: RedBlackNode<T> = node.getUncle();\r\n        if (parent.getColor() !== RedBlackNode.BLACK){\r\n            if (uncle != null && uncle.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.BLACK);\r\n                uncle.setColor(RedBlackNode.BLACK);\r\n                grandParent.setColor(RedBlackNode.RED);\r\n                this.fixRedRed(grandParent);\r\n            } else {\r\n                if (parent.isOnLeft()) {\r\n                    if (node.isOnLeft()) {\r\n                        this.swapColors(parent, grandParent);\r\n                    } else {\r\n                        this.leftRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    }\r\n                    this.rightRotate(grandParent);\r\n                } else {\r\n                    if (node.isOnLeft()) {\r\n                        this.rightRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    } else {\r\n                        this.swapColors(parent, grandParent);\r\n                    }\r\n                    this.leftRotate(grandParent);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (this.root == null) return;\r\n        this.forEachRecursive(this.root, action);\r\n    }\r\n    private forEachRecursive(root: RedBlackNode<T>, action: (item: T) => void): void {\r\n        if (root == null) return;\r\n        this.forEachRecursive(root.getLeft(), action);\r\n        action(root.getData());\r\n        this.forEachRecursive(root.getRight(), action);\r\n    }\r\n    public getNodeCount(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    /**\r\n     * Returns the root node of the tree.\r\n     */\r\n    public getRoot(): RedBlackNode<T> {\r\n        return this.root;\r\n    }\r\n    public getRootData(): T {\r\n        return this.root.getData();\r\n    }\r\n    private getSuccessor(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        let temp = node;\r\n        while (temp.getLeft() != null){\r\n            temp = temp.getLeft();\r\n        }\r\n        return temp;\r\n    }\r\n    /**\r\n     * Inserts an item to the tree.\r\n     * @param item Item to be inserted.\r\n     */\r\n    public insert(item: T): void {\r\n        const node = new RedBlackNode<T>(item);\r\n        if (this.root == null) {\r\n            node.setColor(RedBlackNode.BLACK);\r\n            this.root = node;\r\n        } else {\r\n            const temp: RedBlackNode<T> = this.searchNode(item);\r\n            if (temp.getData() === item) {\r\n                return;\r\n            }\r\n            node.setParent(temp);\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                temp.setLeft(node);\r\n            } else {\r\n                temp.setRight(node);\r\n            }\r\n            this.fixRedRed(node);\r\n        }\r\n    }\r\n    /**\r\n     * Checks whether the tree is empty or not.\r\n     */\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    private leftRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getRight();\r\n        if (node === this.root) {\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p);\r\n        node.setRight(p.getLeft());\r\n        if (p.getLeft() != null) {\r\n            p.getLeft().setParent(node);\r\n        }\r\n        p.setLeft(node);\r\n    }\r\n    private rightRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getLeft();\r\n        if (node === this.root){\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p);\r\n        node.setLeft(p.getRight());\r\n        if (p.getRight() != null) {\r\n            p.getRight().setParent(node);\r\n        }\r\n        p.setRight(node);\r\n    }\r\n    /**\r\n     * Searchs an item in the tree.\r\n     * Returns the node the item belongs to,\r\n     * or null if item does not exists in tree.\r\n     */\r\n    public search(item: T): T {\r\n        const node = this.searchNode(item);\r\n        return node.getData();\r\n    }\r\n    private searchNode(item: T): RedBlackNode<T> {\r\n        let temp: RedBlackNode<T> = this.root;\r\n        while (temp != null) {\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                if (temp.getLeft() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getLeft();\r\n                }\r\n            } else if (item === temp.getData()) {\r\n                break;\r\n            } else {\r\n                if (temp.getRight() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getRight();\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n    private swapColors(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getColor();\r\n        u.setColor(v.getColor());\r\n        v.setColor(temp);\r\n    }\r\n    private swapValues(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getData();\r\n        u.setData(v.getData());\r\n        v.setData(temp);\r\n    }\r\n    /**\r\n     * Maps the tree data into an array inorderly.\r\n     * @param target The array that the data will be mapped into.\r\n     */\r\n    public toArray(target: T[]=[]): T[] {\r\n        if (this.isEmpty()) return target;\r\n        this.toArrayRecursive(this.root, target);\r\n        return target;\r\n    }\r\n    private toArrayRecursive(root: RedBlackNode<T>, target: T[]): void {\r\n        if (root == null) return;\r\n        this.toArrayRecursive(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toArrayRecursive(root.getRight(), target);\r\n    }\r\n}"],"names":["ArgumentNullException","constructor","message","this","Error","ArgumentOutOfRangeException","ArgumentException","List","data","count","length","add","item","push","clear","contains","indexOf","exists","predicate","some","find","findAll","foundData","filter","findIndex","startIndex","Count","foundIndex","ix","findLast","foundItem","elem","findLastIndex","forEach","action","d","get","index","insert","splice","isEmpty","lastIndexOf","remove","removeAt","removeAll","preCount","removeRange","removedCount","reverse","set","sort","comparer","e1","e2","toArray","next","iteratorIndex","Symbol","iterator","prototypeAccessors","InvalidOperationException","Queue","dequeue","enqueue","peek","Stack","pop","BinaryTreeNode","rootData","getLeft","left","getRight","right","setLeft","node","setRight","setData","getData","BinaryTree","comparator","root","containsRecursive","insertRecursive","getNodeCount","countTreeNodes","delete","deleteRecursive","smallestValue","findSmallestValue","findRecursive","forEachRecursive","getRootData","search","searchTree","traverseAndMapToArray","mapper","direction","array","map","v","traverseAndMorph","morpher","tree","e","morphedItem","target","toInorderArray","toPreorderArray","toPostorderArray","RedBlackNode","parent","color","RED","getColor","getParent","getSibling","isOnLeft","getUncle","hasRedChild","moveDown","p","setParent","setColor","BinarySearchTree","v1","v2","searchNode","deleteNode","u","findReplaceItem","bothBlack","BLACK","swapValues","fixDoubleBlack","getSuccessor","sibling","rightRotate","leftRotate","fixRedRed","grandParent","uncle","swapColors","getRoot","temp","toArrayRecursive"],"mappings":"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"}