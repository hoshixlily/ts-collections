{"version":3,"file":"index.es.js","sources":["../src/exceptions/ArgumentNullException.ts","../src/exceptions/ArgumentOutOfRangeException.ts","../src/exceptions/ArgumentException.ts","../src/list/List.ts","../src/exceptions/InvalidOperationException.ts","../src/queue/Queue.ts","../src/stack/Stack.ts","../src/tree/BinaryTreeNode.ts","../src/tree/BinaryTree.ts","../src/tree/BinarySearchTree.ts"],"sourcesContent":["export class ArgumentNullException extends Error {\r\n    name = \"ArgumentNullException\";\r\n    message = \"object is null.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","export class ArgumentOutOfRangeException extends Error {\r\n    public name: string = \"ArgumentOutOfRangeException\";\r\n    public message: string = \"arrayIndex is out of range.\";\r\n    public constructor(message: string) {\r\n        super();\r\n        this.message = message;\r\n    }\r\n}","export class ArgumentException extends Error {\r\n    public name = \"ArgumentException\";\r\n    public message = \"Invalid argument.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if(message) {\r\n            this.message = message;\r\n        }\r\n    }\r\n}","import { IList } from \"./IList\";\r\nimport { ArgumentNullException } from \"../exceptions/ArgumentNullException\";\r\nimport { ArgumentOutOfRangeException } from \"../exceptions/ArgumentOutOfRangeException\";\r\nimport { ArgumentException } from \"../exceptions/ArgumentException\";\r\n\r\nexport class List<T> implements IList<T>, IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    // private enumerator: IEnumerator<T> = null;\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]){\r\n        if(data) {\r\n            this.data = [...data];\r\n            this.count = this.data.length;\r\n        }\r\n    }\r\n    public add(item: T) {\r\n        this.data.push(item);\r\n        this.count++;\r\n    }\r\n    public clear() {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return  this.indexOf(item) > -1;\r\n    }\r\n    // public copyTo(array: T[], arrayIndex: number): void {\r\n    //     if (!array) {\r\n    //         throw new ArgumentNullException(\"array is null.\");\r\n    //     }\r\n    //     if (arrayIndex < 0) {\r\n    //         throw new ArgumentOutOfRangeException(\"array index is less than 0.\");\r\n    //     }\r\n    //     let index = arrayIndex;\r\n    //     for(const item of this.data) {\r\n    //         array.splice(index, 0, item);\r\n    //         index++;\r\n    //     }\r\n    // }\r\n    public exists(predicate: (item: T) => boolean): boolean {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        return this.data.some(predicate);\r\n    }\r\n    public find(predicate: (item: T) => boolean): T|null {\r\n        const item = this.data.find(predicate);\r\n        return item || null;\r\n    }\r\n    public findAll(predicate: (item: T) => boolean): List<T> {\r\n        const foundData = this.data.filter(predicate);\r\n        return new List<T>(foundData);\r\n    }\r\n    public findIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        \r\n        startIndex = startIndex || 0;\r\n        count      = count || this.Count-1;\r\n\r\n        if (startIndex! < 0 || startIndex >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        \r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex; ix < startIndex+count; ++ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public findLast(predicate: (item: T) => boolean): T {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        let found = false;\r\n        let foundItem: T = null;\r\n        for (let ix = this.data.length - 1; ix >= 0; --ix) {\r\n            const elem = this.data[ix];\r\n            found = predicate(elem);\r\n            if (found) {\r\n                foundItem = elem;\r\n                break;\r\n            }\r\n        }\r\n        return foundItem;\r\n    }\r\n    public findLastIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        if (startIndex < 0 || startIndex >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.Count) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        startIndex = startIndex || 0;\r\n        count      = count || this.Count;\r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex+count-1; ix >= startIndex; --ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (!action) {\r\n            throw new ArgumentNullException(\"action is null.\");\r\n        }\r\n        this.data.forEach(d => d ? action(d) : void 0);\r\n    }\r\n    public get(index: number): T {\r\n        if (index == null) {\r\n            throw new ArgumentNullException(\"index is null.\");\r\n        }\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        return this.data[index];\r\n    }\r\n    // public getEnumerator(): IEnumerator<T> {\r\n    //     return this.getListEnumerator();\r\n    // }\r\n    // private getListEnumerator(): IBaseEnumerator {\r\n    //     return new ListEnum(this.data);\r\n    // }\r\n    public indexOf(item: T): number {\r\n        return this.data.findIndex(d => d === item);\r\n    }\r\n    public insert(index: number, item: T) {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data.splice(index, 0, item);\r\n        this.count++;\r\n    }\r\n    public lastIndexOf(item: T): number {\r\n        return this.data.lastIndexOf(item);\r\n    }\r\n    public remove(item: T): boolean {\r\n        const index = this.findIndex(d => d === item);\r\n        if (index === -1) return false;\r\n        this.removeAt(index);\r\n        return true;\r\n    }\r\n    public removeAll(predicate: (value: T) => boolean): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        const preCount = this.Count;\r\n        this.data = this.data.filter(d => !predicate(d));\r\n        this.count = this.data.length;\r\n        return preCount - this.count;\r\n    }\r\n    public removeAt(index: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data.splice(index, 1);\r\n        this.count--;\r\n    }\r\n    public removeRange(index: number, count: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (index+count > this.Count) {\r\n            throw new ArgumentException(\"index and count do not denote a valid range of elements in the list.\");\r\n        }\r\n        let removedCount = 0;\r\n        while(removedCount < count) {\r\n            this.removeAt(index);\r\n            removedCount++;\r\n        }\r\n    }\r\n    public reverse(): void {\r\n        this.data.reverse();\r\n    }\r\n    public set(index: number, item: T): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.Count) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.Count}.`);\r\n        }\r\n        this.data[index] = item;\r\n    }\r\n    public sort(comparer?: (e1: T, e2: T) => number): void {\r\n        if (!comparer) {\r\n            comparer = (e1: T, e2: T) => e1 > e2 ? 1 : -1;\r\n        }\r\n        this.data.sort(comparer);\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n        // if (!this.enumerator) {\r\n        //     this.enumerator = this.getEnumerator();\r\n        // }\r\n        // if(this.enumerator.moveNext()) {\r\n        //     return { done: false, value: this.enumerator.Current };\r\n        // }\r\n        // this.enumerator.reset();\r\n        // return { done: true, value: null };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n\r\n    public get Count() { return this.count; }\r\n}\r\n\r\n// class ListEnum<T> implements IBaseEnumerator {\r\n//     private data: T[];\r\n//     private position: number = -1;\r\n//     public constructor(data: T[]){\r\n//         this.data = data;\r\n//     }\r\n//     public moveNext(): boolean {\r\n//         this.position++;\r\n//         return this.position < this.data.length;\r\n//     }\r\n//     public reset(): void {\r\n//         this.position = -1;\r\n//     }\r\n//     public get Current(): T {\r\n//         return this.data[this.position];\r\n//     }\r\n// }","export class InvalidOperationException extends Error {\r\n    name = \"InvalidOperationException\";\r\n    message = \"Invalid operation.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","import { ICollection } from \"../core/ICollection\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\n\r\nexport class Queue<T> implements IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]) {\r\n        if (data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public clear(): void {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.data.findIndex(d => d === item) > -1;\r\n    }\r\n    public dequeue(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        this.count--;\r\n        return item;\r\n    }\r\n    public enqueue(item: T): void {\r\n        this.data.push(item);\r\n        this.count++;\r\n    }\r\n    public peek(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        return this.data[0];\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n\r\n    public get Count() { return this.count; }\r\n}","import { ICollection } from \"../core/ICollection\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\n\r\nexport class Stack<T> implements IterableIterator<T> {\r\n    private count: number = 0;\r\n    private data: T[] = [];\r\n    private iteratorIndex: number = 0;\r\n    public constructor(data?: T[]) {\r\n        if (data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public clear(): void {\r\n        this.data.length = 0;\r\n        this.count = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.data.findIndex(d => d === item) > -1;\r\n    }\r\n    public peek(): T {\r\n        if (this.Count === 0) {\r\n            throw new InvalidOperationException(\"stack is empty.\");\r\n        }\r\n        return this.data[0];\r\n    }\r\n    public pop(): T {\r\n        if (this.count === 0) {\r\n            throw new InvalidOperationException(\"stack is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        this.count--;\r\n        return item;\r\n    }\r\n    public push(item: T): void {\r\n        this.data.splice(0, 0, item);\r\n        this.count++;\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n\r\n    public next(): IteratorResult<T> {\r\n        if (this.iteratorIndex >= this.Count) {\r\n            this.iteratorIndex = 0;\r\n            return { done: true, value: null };\r\n        }\r\n        return { done: false, value: this.data[this.iteratorIndex++] };\r\n    }\r\n    [Symbol.iterator](): IterableIterator<T> {\r\n        return this;\r\n    }\r\n\r\n    public get Count() { return this.count; }\r\n}","export class BinaryTreeNode<T extends any> {\r\n    private left: BinaryTreeNode<T>;\r\n    private right: BinaryTreeNode<T>;\r\n    private data: T;\r\n    public constructor(rootData?: T) {\r\n        if (rootData) this.data = rootData;\r\n    }\r\n    public getLeft(): BinaryTreeNode<T> {\r\n        return this.left;\r\n    }\r\n    public getRight(): BinaryTreeNode<T> {\r\n        return this.right;\r\n    }\r\n    public setLeft(node: BinaryTreeNode<T>): void {\r\n        this.left = node;\r\n    }\r\n    public setRight(node: BinaryTreeNode<T>): void {\r\n        this.right = node;\r\n    }\r\n    public setData(data: T): void {\r\n        this.data = data;\r\n    }\r\n    public getData(): T {\r\n        return this.data;\r\n    }\r\n}","import { BinaryTreeNode } from \"./BinaryTreeNode\";\r\n\r\nexport declare type TraverseType = \"INORDER\" | \"PREORDER\" | \"POSTORDER\";\r\nexport class BinaryTree<T> {\r\n    private comparator: Function = null;\r\n    private root: BinaryTreeNode<T>;\r\n    public constructor(comparator: Function) {\r\n        this.root = null;\r\n        this.comparator = comparator;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.containsRecursive(this.root, item);\r\n    }\r\n    private containsRecursive(root: BinaryTreeNode<T>, item: T): boolean {\r\n        if (root == null) return false;\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        return this.comparator(item, root.getData()) < 0\r\n            ? this.containsRecursive(root.getLeft(), item)\r\n            : this.containsRecursive(root.getRight(), item);\r\n    }\r\n    public insert(item: T): void {\r\n        this.root = this.insertRecursive(this.root, item);\r\n    }\r\n    private insertRecursive(root: BinaryTreeNode<T>, item: T): BinaryTreeNode<T> {\r\n        if (root == null) return new BinaryTreeNode<T>(item);\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.insertRecursive(root.getLeft(), item));\r\n        } else if (this.comparator(item, root.getData()) > 0) {\r\n            root.setRight(this.insertRecursive(root.getRight(), item));\r\n        } else {\r\n            return root;\r\n        }\r\n        return root;\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    public countNodes(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    private countTreeNodes(root: BinaryTreeNode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    public delete(item: T): void {\r\n        this.root = this.deleteRecursive(this.root, item);\r\n    }\r\n    private deleteRecursive(root: BinaryTreeNode<T>, item: T): BinaryTreeNode<T> {\r\n        if (root == null) return null;\r\n        if (this.comparator(item, root.getData()) === 0) {\r\n            if (root.getLeft() == null && root.getRight() == null) {\r\n                return null;\r\n            }\r\n            if (root.getRight() == null) {\r\n                return root.getLeft();\r\n            }\r\n            if (root.getLeft() == null) {\r\n                return root.getRight();\r\n            }\r\n            const smallestValue = this.findSmallestValue(root.getRight());\r\n            root.setData(smallestValue);\r\n            root.setRight(this.deleteRecursive(root.getRight(), smallestValue));\r\n            return root;\r\n        }\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.deleteRecursive(root.getLeft(), item));\r\n            return root;\r\n        }\r\n        root.setRight(this.deleteRecursive(root.getRight(), item));\r\n        return root;\r\n    }\r\n    public find(predicate: (item: T) => boolean): T {\r\n        if (this.root == null) return null;\r\n        return this.findRecursive(this.root, predicate);\r\n    }\r\n    private findRecursive(root: BinaryTreeNode<T>, predicate: (item: T) => boolean): T {\r\n        if (root == null) return null;\r\n        if (predicate(root.getData())) return root.getData();\r\n        let foundItem: T = this.findRecursive(root.getLeft(), predicate);\r\n        if (foundItem != null){\r\n            return foundItem;\r\n        }\r\n        return this.findRecursive(root.getRight(), predicate);\r\n    }\r\n    private findSmallestValue(root: BinaryTreeNode<T>): T {\r\n        return root.getLeft() == null ? root.getData() : this.findSmallestValue(root.getLeft());\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (this.root == null) return;\r\n        this.forEachRecursive(this.root, action);\r\n    }\r\n    private forEachRecursive(root: BinaryTreeNode<T>, action: (item: T) => void): void {\r\n        if (root == null) return;\r\n        this.forEachRecursive(root.getLeft(), action);\r\n        action(root.getData());\r\n        this.forEachRecursive(root.getRight(), action);\r\n    }\r\n    public getRootData(): T {\r\n        return this.root == null ? null : this.root.getData();\r\n    }\r\n    public search(item: T): boolean {\r\n       return this.searchTree(this.root, item);\r\n    }\r\n    private searchTree(root: BinaryTreeNode<T>, item: T): boolean {\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        if (root.getLeft() != null) {\r\n            if (this.searchTree(root.getLeft(), item)) return true;\r\n        }\r\n        if (root.getRight() != null) {\r\n            if (this.searchTree(root.getRight(), item)) return true;\r\n        }\r\n        return false;\r\n    }\r\n    public traverseAndMapToArray<R>(mapper: (item: T) => R, direction: TraverseType = \"INORDER\"): R[] {\r\n        let array: T[] = [];\r\n        switch(direction) {\r\n            case \"INORDER\":\r\n                array = this.toArray(\"INORDER\");\r\n                break;\r\n            case \"PREORDER\":\r\n                array = this.toArray(\"PREORDER\");\r\n                break;\r\n            case \"POSTORDER\":\r\n                array = this.toArray(\"POSTORDER\");\r\n                break;\r\n        }\r\n        return array.map(v => mapper(v));\r\n    }\r\n    public traverseAndMorph<R>(morpher: (item: T) => R, comparator?: (i1: R, i2: R) => number): BinaryTree<R> {\r\n        const compare  = comparator || this.comparator;\r\n        const tree     = new BinaryTree<R>(compare);\r\n        let array: T[] = [];\r\n        array = this.toArray(\"PREORDER\");\r\n        array.forEach(e => {\r\n            const morphedItem = morpher(e);\r\n            tree.insert(morphedItem);\r\n        });\r\n        return tree;\r\n    }\r\n    public toArray(direction: TraverseType = \"INORDER\"): T[] {\r\n        const target: T[] = [];\r\n        switch (direction) {\r\n            case \"INORDER\":\r\n                this.toInorderArray(this.root, target);\r\n                return target;\r\n            case \"PREORDER\":\r\n                this.toPreorderArray(this.root, target);\r\n                return target;\r\n            case \"POSTORDER\":\r\n                this.toPostorderArray(this.root, target);\r\n                return target;\r\n            default:\r\n                this.toInorderArray(this.root, target);\r\n                return target;\r\n        }\r\n    }\r\n    private toInorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toInorderArray(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toInorderArray(root.getRight(), target);\r\n    }\r\n    private toPostorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toPostorderArray(root.getLeft(), target);\r\n        this.toPostorderArray(root.getRight(), target);\r\n        target.push(root.getData());\r\n    }\r\n    private toPreorderArray(root: BinaryTreeNode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        target.push(root.getData());\r\n        this.toPreorderArray(root.getLeft(), target);\r\n        this.toPreorderArray(root.getRight(), target);\r\n    }\r\n}","// Algorithm taken from https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/\r\nclass RedBlackNode<T> {\r\n    public static readonly RED   = 0;\r\n    public static readonly BLACK = 1;\r\n    private data: T;\r\n    private left: RedBlackNode<T>;\r\n    private parent: RedBlackNode<T>;\r\n    private right: RedBlackNode<T>;\r\n    private color: number;\r\n    public constructor(data: T) {\r\n        this.parent = this.left = this.right = null;\r\n        this.color = RedBlackNode.RED;\r\n        this.data  = data;\r\n    }\r\n    public getData(): T { return this.data; }\r\n    public getColor(): number { return this.color; }\r\n    public getLeft(): RedBlackNode<T> { return this.left; }\r\n    public getParent(): RedBlackNode<T> { return this.parent; }\r\n    public getRight(): RedBlackNode<T> { return this.right; }\r\n    public getSibling(): RedBlackNode<T> {\r\n        if (this.parent == null) return null;\r\n        if (this.isOnLeft()) return this.parent.getRight();\r\n        return this.parent.getLeft();\r\n    }\r\n    public getUncle(): RedBlackNode<T> {\r\n        if (this.parent == null || this.parent.getParent() == null){\r\n            return null;\r\n        }\r\n        if (this.parent.isOnLeft()){\r\n            return this.parent.getParent().getRight();\r\n        }\r\n        return this.parent.getParent().getLeft();\r\n    }\r\n    public hasRedChild(): boolean {\r\n        return (this.left != null && this.left.color === RedBlackNode.RED)\r\n            || (this.right != null && this.right.color === RedBlackNode.RED);\r\n    }\r\n    public isOnLeft(): boolean {\r\n        return this.parent.getLeft() === this;\r\n    }\r\n    public moveDown(p: RedBlackNode<T>): void { //p: parentnode\r\n        if (this.parent != null) {\r\n            if (this.isOnLeft()) {\r\n                this.parent.setLeft(p);\r\n            } else {\r\n                this.parent.setRight(p);\r\n            }\r\n        }\r\n        p.setParent(this.parent);\r\n        this.parent = p;\r\n    }\r\n    public setColor(color: number): void { this.color = color; }\r\n    public setData(data: T): void { this.data = data; }\r\n    public setLeft(left: RedBlackNode<T>): void { this.left = left; }\r\n    public setParent(parent: RedBlackNode<T>): void { this.parent = parent; }\r\n    public setRight(right: RedBlackNode<T>): void { this.right = right; }\r\n}\r\n\r\nexport class BinarySearchTree<T> {\r\n    private root: RedBlackNode<T>;\r\n    private comparator: Function = (v1:T|any, v2:T|any) => v1 - v2;\r\n    public constructor(comparator?: Function){\r\n        if (comparator) this.comparator = comparator;\r\n        this.root = null;\r\n    }\r\n    /**\r\n     * Returns the number of nodes in the tree.\r\n     */\r\n    public countNodes(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    private countTreeNodes(root: RedBlackNode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    /**\r\n     * Removes an item from the tree.\r\n     * @param item The item to be removed from tree.\r\n     */\r\n    public delete(item: T): void {\r\n        if (this.root == null) return;\r\n        let v: RedBlackNode<T> = this.searchNode(item);\r\n        if (v.getData() !== item) {\r\n            return;\r\n        }\r\n        this.deleteNode(v);\r\n    }\r\n    private deleteNode(v: RedBlackNode<T>): void {\r\n        let u: RedBlackNode<T> = this.findReplaceItem(v);\r\n        const bothBlack = ((u == null || u.getColor() === RedBlackNode.BLACK) && v.getColor() === RedBlackNode.BLACK);\r\n        let parent: RedBlackNode<T> = v.getParent();\r\n        if (u === null) {\r\n            if (v === this.root) {\r\n                this.root = null;\r\n            } else {\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(v);\r\n                } else {\r\n                    if (v.getSibling() != null) {\r\n                        v.getSibling().setColor(RedBlackNode.RED);\r\n                    }\r\n                }\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(null);\r\n                } else {\r\n                    parent.setRight(null);\r\n                }\r\n            }\r\n            // v = null;\r\n            return;\r\n        }\r\n        if (v.getLeft() == null || v.getRight() == null) {\r\n            if (v === this.root) {\r\n                v.setData(u.getData());\r\n                v.setLeft(null);\r\n                v.setRight(null);\r\n                // u = null;\r\n            } else {\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(u);\r\n                } else {\r\n                    parent.setRight(u);\r\n                }\r\n                // v = null;\r\n                u.setParent(parent);\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(u);\r\n                } else {\r\n                    u.setColor(RedBlackNode.BLACK);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        this.swapValues(u, v);\r\n        this.deleteNode(u);\r\n    }\r\n    private findReplaceItem(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        if (node.getLeft() != null && node.getRight() != null) {\r\n            return this.getSuccessor(node.getRight());\r\n        }\r\n        if (node.getLeft() == null && node.getRight() == null) {\r\n            return null;\r\n        }\r\n        if (node.getLeft() != null){\r\n            return node.getLeft();\r\n        }\r\n        return node.getRight();\r\n    }\r\n    private fixDoubleBlack(node: RedBlackNode<T>): void {\r\n        if (node === this.root) return;\r\n        let sibling = node.getSibling();\r\n        let parent  = node.getParent();\r\n        if (sibling == null) {\r\n            this.fixDoubleBlack(parent);\r\n        } else {\r\n            if (sibling.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.RED);\r\n                sibling.setColor(RedBlackNode.BLACK);\r\n                if (sibling.isOnLeft()) {\r\n                    this.rightRotate(parent);\r\n                } else {\r\n                    this.leftRotate(parent);\r\n                }\r\n                this.fixDoubleBlack(node);\r\n            } else {\r\n                if (sibling.hasRedChild()) {\r\n                    if (sibling.getLeft() != null && sibling.getLeft().getColor() === RedBlackNode.RED) {\r\n                        if (sibling.isOnLeft()) {\r\n                            sibling.getLeft().setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            sibling.getLeft().setColor(parent.getColor());\r\n                            this.rightRotate(sibling);\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    } else {\r\n                        if (sibling.isOnLeft()) {\r\n                            sibling.getRight().setColor(parent.getColor());\r\n                            this.leftRotate(sibling);\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            sibling.getRight().setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    }\r\n                    parent.setColor(RedBlackNode.BLACK);\r\n                } else {\r\n                    sibling.setColor(RedBlackNode.RED);\r\n                    if (parent.getColor() === RedBlackNode.BLACK) {\r\n                        this.fixDoubleBlack(parent);\r\n                    } else {\r\n                        parent.setColor(RedBlackNode.BLACK);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private fixRedRed(node: RedBlackNode<T>): void {\r\n        if (node === this.root){\r\n            node.setColor(RedBlackNode.BLACK);\r\n            return;\r\n        }\r\n        let parent: RedBlackNode<T> = node.getParent();\r\n        let grandParent: RedBlackNode<T> = parent.getParent();\r\n        let uncle: RedBlackNode<T> = node.getUncle();\r\n        if (parent.getColor() !== RedBlackNode.BLACK){\r\n            if (uncle != null && uncle.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.BLACK);\r\n                uncle.setColor(RedBlackNode.BLACK);\r\n                grandParent.setColor(RedBlackNode.RED);\r\n                this.fixRedRed(grandParent);\r\n            } else {\r\n                if (parent.isOnLeft()) {\r\n                    if (node.isOnLeft()) {\r\n                        this.swapColors(parent, grandParent);\r\n                    } else {\r\n                        this.leftRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    }\r\n                    this.rightRotate(grandParent);\r\n                } else {\r\n                    if (node.isOnLeft()) {\r\n                        this.rightRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    } else {\r\n                        this.swapColors(parent, grandParent);\r\n                    }\r\n                    this.leftRotate(grandParent);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Returns the root node of the tree.\r\n     */\r\n    public getRoot(): RedBlackNode<T> {\r\n        return this.root;\r\n    }\r\n    private getSuccessor(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        let temp = node;\r\n        while (temp.getLeft() != null){\r\n            temp = temp.getLeft();\r\n        }\r\n        return temp;\r\n    }\r\n    /**\r\n     * Inserts an item to the tree.\r\n     * @param item Item to be inserted.\r\n     */\r\n    public insert(item: T): void {\r\n        const node = new RedBlackNode<T>(item);\r\n        if (this.root == null) {\r\n            node.setColor(RedBlackNode.BLACK);\r\n            this.root = node;\r\n        } else {\r\n            const temp: RedBlackNode<T> = this.searchNode(item);\r\n            if (temp.getData() === item) {\r\n                return;\r\n            }\r\n            node.setParent(temp);\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                temp.setLeft(node);\r\n            } else {\r\n                temp.setRight(node);\r\n            }\r\n            this.fixRedRed(node);\r\n        }\r\n    }\r\n    /**\r\n     * Checks whether the tree is empty or not.\r\n     */\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    private leftRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getRight();\r\n        if (node === this.root) {\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p);\r\n        node.setRight(p.getLeft());\r\n        if (p.getLeft() != null) {\r\n            p.getLeft().setParent(node);\r\n        }\r\n        p.setLeft(node);\r\n    }\r\n    private rightRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getLeft();\r\n        if (node === this.root){\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p);\r\n        node.setLeft(p.getRight());\r\n        if (p.getRight() != null) {\r\n            p.getRight().setParent(node);\r\n        }\r\n        p.setRight(node);\r\n    }\r\n    /**\r\n     * Searchs an item in the tree.\r\n     * Returns the node the item belongs to,\r\n     * or null if item does not exists in tree.\r\n     */\r\n    public search(item: T): T {\r\n        const node = this.searchNode(item);\r\n        return node.getData();\r\n    }\r\n    private searchNode(item: T): RedBlackNode<T> {\r\n        let temp: RedBlackNode<T> = this.root;\r\n        while (temp != null) {\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                if (temp.getLeft() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getLeft();\r\n                }\r\n            } else if (item === temp.getData()) {\r\n                break;\r\n            } else {\r\n                if (temp.getRight() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getRight();\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n    private swapColors(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getColor();\r\n        u.setColor(v.getColor());\r\n        v.setColor(temp);\r\n    }\r\n    private swapValues(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getData();\r\n        u.setData(v.getData());\r\n        v.setData(temp);\r\n    }\r\n    /**\r\n     * Maps the tree data into an array inorderly.\r\n     * @param target The array that the data will be mapped into.\r\n     */\r\n    public toArray(target: T[]=[]): T[] {\r\n        if (this.isEmpty()) return target;\r\n        this.toArrayRecursive(this.root, target);\r\n        return target;\r\n    }\r\n    private toArrayRecursive(root: RedBlackNode<T>, target: T[]): void {\r\n        if (root == null) return;\r\n        this.toArrayRecursive(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toArrayRecursive(root.getRight(), target);\r\n    }\r\n}"],"names":["ArgumentNullException","constructor","message","this","Error","ArgumentOutOfRangeException","ArgumentException","List","data","count","length","add","item","push","clear","contains","indexOf","exists","predicate","some","find","findAll","foundData","filter","findIndex","startIndex","Count","foundIndex","ix","findLast","foundItem","elem","findLastIndex","forEach","action","d","get","index","insert","splice","lastIndexOf","remove","removeAt","removeAll","preCount","removeRange","removedCount","reverse","set","sort","comparer","e1","e2","toArray","next","iteratorIndex","Symbol","iterator","prototypeAccessors","InvalidOperationException","Queue","dequeue","enqueue","peek","Stack","pop","BinaryTreeNode","rootData","getLeft","left","getRight","right","setLeft","node","setRight","setData","getData","BinaryTree","comparator","root","containsRecursive","insertRecursive","isEmpty","countNodes","countTreeNodes","delete","deleteRecursive","smallestValue","findSmallestValue","findRecursive","forEachRecursive","getRootData","search","searchTree","traverseAndMapToArray","mapper","direction","array","map","v","traverseAndMorph","morpher","tree","e","morphedItem","target","toInorderArray","toPreorderArray","toPostorderArray","RedBlackNode","parent","color","RED","getColor","getParent","getSibling","isOnLeft","getUncle","hasRedChild","moveDown","p","setParent","setColor","BinarySearchTree","v1","v2","searchNode","deleteNode","u","findReplaceItem","bothBlack","BLACK","swapValues","fixDoubleBlack","getSuccessor","sibling","rightRotate","leftRotate","fixRedRed","grandParent","uncle","swapColors","getRoot","temp","toArrayRecursive"],"mappings":"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"}