{"version":3,"file":"index.umd.js","sources":["../src/core/AbstractCollection.ts","../src/tree/AbstractTree.ts","../src/tree/TreeNode.ts","../src/tree/BinarySearchTree.ts","../src/tree/BinaryTree.ts","../src/exceptions/ArgumentNullException.ts","../src/exceptions/ArgumentOutOfRangeException.ts","../src/exceptions/ArgumentException.ts","../src/exceptions/InvalidOperationException.ts","../src/list/List.ts","../src/set/TreeSet.ts"],"sourcesContent":["import { ICollection } from \"./ICollection\";\r\nimport { Constructor } from \"./Constructor\";\r\nimport { ITransform } from \"./ITransform\";\r\n\r\nexport abstract class AbstractCollection<T> implements ICollection<T>, ITransform<T> {\r\n\tabstract add(item: T): boolean;\r\n\tabstract clear(): void;\r\n\tabstract contains(item: T): boolean;\r\n\tabstract isEmpty(): boolean;\r\n\tabstract remove(item: T): boolean;\r\n\tabstract size(): number;\r\n\tabstract toArray(): T[];\r\n\ttransform<U extends ICollection<T>>(Collection: Constructor<U>, comparator?: (v1: T, v2: T) => number): U {\r\n\t\tconst collection = new Collection(comparator);\r\n\t\tthis.toArray().forEach(item => collection.add(item));\r\n\t\treturn collection;\r\n\t}\r\n}\r\n","import { ITree, TraverseType } from \"./ITree\";\r\nimport { INode } from \"./INode\";\r\nimport { Constructor } from \"../core/Constructor\";\r\nimport { ICollection } from \"../core/ICollection\";\r\nimport { AbstractCollection } from \"../core/AbstractCollection\";\r\n\r\nexport abstract class AbstractTree<T> extends AbstractCollection<T> implements ITree<T> {\r\n    protected comparator: Function = null;\r\n    protected root: INode<T>;\r\n    protected constructor(comparator: Function) {\r\n        super();\r\n        this.comparator = comparator;\r\n    }\r\n    public clear(): void {\r\n        this.root = null;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.containsRecursive(this.root, item);\r\n    }\r\n    private containsRecursive(root: INode<T>, item: T): boolean {\r\n        if (root == null) return false;\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        return this.comparator(item, root.getData()) < 0\r\n            ? this.containsRecursive(root.getLeft(), item)\r\n            : this.containsRecursive(root.getRight(), item);\r\n    }\r\n    private countTreeNodes(root: INode<T>): number {\r\n        if (root == null) return 0;\r\n        return 1 + this.countTreeNodes(root.getLeft()) + this.countTreeNodes(root.getRight());\r\n    }\r\n    public find(predicate: (item: T) => boolean): T {\r\n        if (this.root == null) return null;\r\n        return this.findRecursive(<INode<T>>this.root, predicate);\r\n    }\r\n    private findRecursive(root: INode<T>, predicate: (item: T) => boolean): T {\r\n        if (root == null) return null;\r\n        if (predicate(root.getData())) return root.getData();\r\n        let foundItem: T = this.findRecursive(root.getLeft(), predicate);\r\n        if (foundItem != null){\r\n            return foundItem;\r\n        }\r\n        return this.findRecursive(root.getRight(), predicate);\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (this.root == null) return;\r\n        this.forEachRecursive(this.root, action);\r\n    }\r\n    private forEachRecursive(root: INode<T>, action: (item: T) => void): void {\r\n        if (root == null) return;\r\n        this.forEachRecursive(root.getLeft(), action);\r\n        action(root.getData());\r\n        this.forEachRecursive(root.getRight(), action);\r\n    }\r\n    public getRootData(): T {\r\n        if (!this.root) return null;\r\n        return this.root.getData();\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.root == null;\r\n    }\r\n    public remove(item: T): boolean {\r\n        if(!this.contains(item)) return false;\r\n        this.delete(item);\r\n        return true;\r\n    }\r\n    public size(): number {\r\n        return this.countTreeNodes(this.root);\r\n    }\r\n    public toArray(): T[] {\r\n        const target: T[] = [];\r\n        if (this.isEmpty()) return target;\r\n        this.toArrayRecursive(<INode<T>>this.root, target);\r\n        return target;\r\n    }\r\n    private toArrayRecursive(root: INode<T>, target: T[]): void {\r\n        if (root == null) return;\r\n        this.toArrayRecursive(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toArrayRecursive(root.getRight(), target);\r\n    }\r\n    protected toInorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toInorderArray(root.getLeft(), target);\r\n        target.push(root.getData());\r\n        this.toInorderArray(root.getRight(), target);\r\n    }\r\n    protected toPostorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        this.toPostorderArray(root.getLeft(), target);\r\n        this.toPostorderArray(root.getRight(), target);\r\n        target.push(root.getData());\r\n    }\r\n    protected toPreorderArray(root: INode<T>, target: T[]) {\r\n        if (root == null) return;\r\n        target.push(root.getData());\r\n        this.toPreorderArray(root.getLeft(), target);\r\n        this.toPreorderArray(root.getRight(), target);\r\n    }\r\n    \r\n    public transform<U extends ICollection<T>>(Collection: Constructor<U>, comparator?: (v1: T, v2: T) => number): U {\r\n        const c = new Collection(comparator);\r\n        this.transformRecursive(this.root, c);\r\n        return c;\r\n    }\r\n    private transformRecursive<U extends ICollection<T>>(root: INode<T>, collection: U): void {\r\n        if (root == null) return;\r\n        collection.add(root.getData());\r\n        this.transformRecursive(root.getLeft(), collection);\r\n        this.transformRecursive(root.getRight(), collection);\r\n    }\r\n    \r\n    /**\r\n     * Traverses the tree and applies the mapper function to each item.\r\n     * @param  mapper The function that will be applied to each item.\r\n     * @param  direction The direction of the traverse. (In-order, Pre-order, Post-order)\r\n     * @return An array containing all the items of the tree. Order is defined by direction.\r\n     */\r\n    public traverseAndMapToArray<R>(mapper: (item: T) => R, direction: TraverseType = \"INORDER\"): R[] {\r\n        let array: T[] = [];\r\n        switch(direction) {\r\n            case \"INORDER\":\r\n                this.toInorderArray(this.root, array);\r\n                break;\r\n            case \"PREORDER\":\r\n                this.toPreorderArray(this.root, array);\r\n                break;\r\n            case \"POSTORDER\":\r\n                this.toPostorderArray(this.root, array);\r\n                break;\r\n        }\r\n        return array.map(v => mapper(v));\r\n    }\r\n\r\n    public abstract add(item: T): boolean;\r\n    public abstract delete(item: T): void;\r\n    public abstract insert(item: T): void;\r\n    // public abstract remove(item: T): boolean;\r\n    public abstract search(item: T): boolean;\r\n}\r\n","import { INode } from \"./INode\";\r\n\r\nexport class TreeNode<T> implements INode<T> {\r\n    private data: T;\r\n    private left: INode<T>;\r\n    private right: INode<T>;\r\n    public constructor(data: T) {\r\n        this.data = data;\r\n    }\r\n    public getData(): T {\r\n        return this.data;\r\n    }\r\n    public getLeft(): INode<T> {\r\n        return this.left;\r\n    }\r\n    public getRight(): INode<T> {\r\n        return this.right;\r\n    }\r\n    public setData(data: T): void {\r\n        this.data = data;\r\n    }\r\n    public setLeft(node: INode<T>): void {\r\n        this.left = node;\r\n    }\r\n    public setRight(node: INode<T>): void {\r\n        this.right = node;\r\n    }\r\n}","import { AbstractTree } from \"./AbstractTree\";\r\nimport { TreeNode } from \"./TreeNode\";\r\n\r\n// Algorithm taken from https://www.geeksforgeeks.org/red-black-tree-set-3-delete-2/\r\nclass RedBlackNode<T> extends TreeNode<T> {\r\n    public static readonly RED   = 0;\r\n    public static readonly BLACK = 1;\r\n    private parent: RedBlackNode<T>;\r\n    private color: number;\r\n    public constructor(data: T) {\r\n        super(data);\r\n        this.setLeft(null);\r\n        this.setRight(null);\r\n        this.parent = null;\r\n        this.color = RedBlackNode.RED;\r\n    }\r\n    public getColor(): number { return this.color; }\r\n    public getParent(): RedBlackNode<T> { return this.parent; }\r\n    public getSibling(): RedBlackNode<T> {\r\n        if (this.parent == null) return null;\r\n        if (this.isOnLeft()) return this.parent.getRight() as RedBlackNode<T>;\r\n        return this.parent.getLeft() as RedBlackNode<T>;\r\n    }\r\n    public getUncle(): RedBlackNode<T> {\r\n        if (this.parent == null || this.parent.getParent() == null){\r\n            return null;\r\n        }\r\n        if (this.parent.isOnLeft()){\r\n            return this.parent.getParent().getRight() as RedBlackNode<T>;\r\n        }\r\n        return this.parent.getParent().getLeft() as RedBlackNode<T>;\r\n    }\r\n    public hasRedChild(): boolean {\r\n        return (this.getLeft() != null && (this.getLeft() as RedBlackNode<T>).getColor() === RedBlackNode.RED)\r\n            || (this.getRight() != null && (this.getRight() as RedBlackNode<T>).getColor() === RedBlackNode.RED);\r\n    }\r\n    public isOnLeft(): boolean {\r\n        return this.parent.getLeft() === this;\r\n    }\r\n    public moveDown(p: RedBlackNode<T>): void { //p: parentnode\r\n        if (this.parent != null) {\r\n            if (this.isOnLeft()) {\r\n                this.parent.setLeft(p);\r\n            } else {\r\n                this.parent.setRight(p);\r\n            }\r\n        }\r\n        p.setParent(this.parent);\r\n        this.parent = p;\r\n    }\r\n    public setColor(color: number): void { this.color = color; }\r\n    public setParent(parent: RedBlackNode<T>): void { this.parent = parent; }\r\n}\r\n\r\nexport class BinarySearchTree<T> extends AbstractTree<T> {\r\n    public constructor(comparator: Function){\r\n        super(comparator);\r\n        this.root = null;\r\n    }\r\n    public add(item: T): boolean {\r\n        if(this.search(item)) return false;\r\n        this.insert(item);\r\n        return true;\r\n    }\r\n    public delete(item: T): void {\r\n        if (!this.contains(item)) return;\r\n        let v: RedBlackNode<T> = this.searchNode(item);\r\n        this.deleteNode(v);\r\n    }\r\n    private deleteNode(v: RedBlackNode<T>): void {\r\n        let u: RedBlackNode<T> = this.findReplaceItem(v);\r\n        const bothBlack = ((u == null || u.getColor() === RedBlackNode.BLACK) && v.getColor() === RedBlackNode.BLACK);\r\n        let parent: RedBlackNode<T> = v.getParent();\r\n        if (u === null) {\r\n            if (v === this.root) {\r\n                this.root = null;\r\n            } else {\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(v);\r\n                } else {\r\n                    if (v.getSibling() != null) {\r\n                        v.getSibling().setColor(RedBlackNode.RED);\r\n                    }\r\n                }\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(null);\r\n                } else {\r\n                    parent.setRight(null);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        if (v.getLeft() == null || v.getRight() == null) {\r\n            if (v === this.root) {\r\n                v.setData(u.getData());\r\n                v.setLeft(null);\r\n                v.setRight(null);\r\n            } else {\r\n                if (v.isOnLeft()) {\r\n                    parent.setLeft(u);\r\n                } else {\r\n                    parent.setRight(u);\r\n                }\r\n                u.setParent(parent);\r\n                if (bothBlack) {\r\n                    this.fixDoubleBlack(u);\r\n                } else {\r\n                    u.setColor(RedBlackNode.BLACK);\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        this.swapValues(u, v);\r\n        this.deleteNode(u);\r\n    }\r\n    private findReplaceItem(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        if (node.getLeft() != null && node.getRight() != null) {\r\n            return this.getSuccessor(node.getRight() as RedBlackNode<T>);\r\n        }\r\n        if (node.getLeft() == null && node.getRight() == null) {\r\n            return null;\r\n        }\r\n        if (node.getLeft() != null){\r\n            return node.getLeft() as RedBlackNode<T>;\r\n        }\r\n        return node.getRight() as RedBlackNode<T>;\r\n    }\r\n    private fixDoubleBlack(node: RedBlackNode<T>): void {\r\n        if (node === this.root) return;\r\n        let sibling = node.getSibling();\r\n        let parent  = node.getParent();\r\n        if (sibling == null) {\r\n            this.fixDoubleBlack(parent);\r\n        } else {\r\n            if (sibling.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.RED);\r\n                sibling.setColor(RedBlackNode.BLACK);\r\n                if (sibling.isOnLeft()) {\r\n                    this.rightRotate(parent);\r\n                } else {\r\n                    this.leftRotate(parent);\r\n                }\r\n                this.fixDoubleBlack(node);\r\n            } else {\r\n                if (sibling.hasRedChild()) {\r\n                    if ((sibling.getLeft() as RedBlackNode<T>) != null && (sibling.getLeft() as RedBlackNode<T>).getColor() === RedBlackNode.RED) {\r\n                        if (sibling.isOnLeft()) {\r\n                            (sibling.getLeft() as RedBlackNode<T>).setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            (sibling.getLeft() as RedBlackNode<T>).setColor(parent.getColor());\r\n                            this.rightRotate(sibling);\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    } else {\r\n                        if (sibling.isOnLeft()) {\r\n                            (sibling.getRight() as RedBlackNode<T>).setColor(parent.getColor());\r\n                            this.leftRotate(sibling);\r\n                            this.rightRotate(parent);\r\n                        } else {\r\n                            (sibling.getRight() as RedBlackNode<T>).setColor(sibling.getColor());\r\n                            sibling.setColor(parent.getColor());\r\n                            this.leftRotate(parent);\r\n                        }\r\n                    }\r\n                    parent.setColor(RedBlackNode.BLACK);\r\n                } else {\r\n                    sibling.setColor(RedBlackNode.RED);\r\n                    if (parent.getColor() === RedBlackNode.BLACK) {\r\n                        this.fixDoubleBlack(parent);\r\n                    } else {\r\n                        parent.setColor(RedBlackNode.BLACK);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private fixDoubleRed(node: RedBlackNode<T>): void {\r\n        if (node === this.root){\r\n            node.setColor(RedBlackNode.BLACK);\r\n            return;\r\n        }\r\n        let parent: RedBlackNode<T> = node.getParent();\r\n        let grandParent: RedBlackNode<T> = parent.getParent();\r\n        let uncle: RedBlackNode<T> = node.getUncle();\r\n        if (parent.getColor() !== RedBlackNode.BLACK){\r\n            if (uncle != null && uncle.getColor() === RedBlackNode.RED) {\r\n                parent.setColor(RedBlackNode.BLACK);\r\n                uncle.setColor(RedBlackNode.BLACK);\r\n                grandParent.setColor(RedBlackNode.RED);\r\n                this.fixDoubleRed(grandParent);\r\n            } else {\r\n                if (parent.isOnLeft()) {\r\n                    if (node.isOnLeft()) {\r\n                        this.swapColors(parent, grandParent);\r\n                    } else {\r\n                        this.leftRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    }\r\n                    this.rightRotate(grandParent);\r\n                } else {\r\n                    if (node.isOnLeft()) {\r\n                        this.rightRotate(parent);\r\n                        this.swapColors(node, grandParent);\r\n                    } else {\r\n                        this.swapColors(parent, grandParent);\r\n                    }\r\n                    this.leftRotate(grandParent);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private getSuccessor(node: RedBlackNode<T>): RedBlackNode<T> {\r\n        let temp = node;\r\n        while (temp.getLeft() != null){\r\n            temp = temp.getLeft() as RedBlackNode<T>;\r\n        }\r\n        return temp;\r\n    }\r\n    public insert(item: T): void {\r\n        const node = new RedBlackNode<T>(item);\r\n        if (this.root == null) {\r\n            node.setColor(RedBlackNode.BLACK);\r\n            this.root = node;\r\n        } else {\r\n            const temp: RedBlackNode<T> = this.searchNode(item);\r\n            if (temp.getData() === item) {\r\n                return;\r\n            }\r\n            node.setParent(temp);\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                temp.setLeft(node);\r\n            } else {\r\n                temp.setRight(node);\r\n            }\r\n            this.fixDoubleRed(node);\r\n        }\r\n    }\r\n    private leftRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getRight();\r\n        if (node === this.root) {\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p as RedBlackNode<T>);\r\n        node.setRight(p.getLeft() as RedBlackNode<T>);\r\n        if (p.getLeft() != null) {\r\n            (p.getLeft() as RedBlackNode<T>).setParent(node);\r\n        }\r\n        p.setLeft(node);\r\n    }\r\n    private rightRotate(node: RedBlackNode<T>): void {\r\n        let p = node.getLeft();\r\n        if (node === this.root){\r\n            this.root = p;\r\n        }\r\n        node.moveDown(p as RedBlackNode<T>);\r\n        node.setLeft(p.getRight());\r\n        if (p.getRight() != null) {\r\n            (p.getRight() as RedBlackNode<T>).setParent(node);\r\n        }\r\n        p.setRight(node);\r\n    }\r\n    public search(item: T): boolean {\r\n        const node = this.searchNode(item);\r\n        if (node == null) return false;\r\n        return this.comparator(node.getData(), item) === 0;\r\n    }\r\n    private searchNode(item: T): RedBlackNode<T> {\r\n        let temp: RedBlackNode<T> = this.root as RedBlackNode<T>;\r\n        while (temp != null) {\r\n            if (this.comparator(item, temp.getData()) < 0) {\r\n                if (temp.getLeft() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getLeft() as RedBlackNode<T>;\r\n                }\r\n            } else if (item === temp.getData()) {\r\n                break;\r\n            } else {\r\n                if (temp.getRight() == null) {\r\n                    break;\r\n                } else {\r\n                    temp = temp.getRight() as RedBlackNode<T>;\r\n                }\r\n            }\r\n        }\r\n        return temp;\r\n    }\r\n    private swapColors(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getColor();\r\n        u.setColor(v.getColor());\r\n        v.setColor(temp);\r\n    }\r\n    private swapValues(u: RedBlackNode<T>, v: RedBlackNode<T>): void {\r\n        let temp = u.getData();\r\n        u.setData(v.getData());\r\n        v.setData(temp);\r\n    }\r\n}","import { AbstractTree } from \"./AbstractTree\";\r\nimport { TreeNode } from \"./TreeNode\";\r\nexport class BinaryTree<T> extends AbstractTree<T> {\r\n    public constructor(comparator: Function) {\r\n        super(comparator);\r\n        this.root = null;\r\n    }\r\n    public add(item: T): boolean {\r\n        if(this.search(item)) return false;\r\n        this.insert(item);\r\n        return true;\r\n    }\r\n    public delete(item: T): void {\r\n        this.root = this.deleteRecursive(this.root as TreeNode<T>, item);\r\n    }\r\n    private deleteRecursive(root: TreeNode<T>, item: T): TreeNode<T> {\r\n        if (root == null) return null;\r\n        if (this.comparator(item, root.getData()) === 0) {\r\n            if (root.getLeft() == null && root.getRight() == null) {\r\n                return null;\r\n            }\r\n            if (root.getRight() == null) {\r\n                return root.getLeft() as TreeNode<T>;\r\n            }\r\n            if (root.getLeft() == null) {\r\n                return root.getRight() as TreeNode<T>;\r\n            }\r\n            const smallestValue = this.findSmallestValue(root.getRight() as TreeNode<T>);\r\n            root.setData(smallestValue);\r\n            root.setRight(this.deleteRecursive(root.getRight() as TreeNode<T>, smallestValue));\r\n            return root;\r\n        }\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.deleteRecursive(root.getLeft() as TreeNode<T>, item));\r\n            return root;\r\n        }\r\n        root.setRight(this.deleteRecursive(root.getRight() as TreeNode<T>, item));\r\n        return root;\r\n    }\r\n    private findSmallestValue(root: TreeNode<T>): T {\r\n        return root.getLeft() == null ? root.getData() : this.findSmallestValue(root.getLeft() as TreeNode<T>);\r\n    }\r\n    public insert(item: T): void {\r\n        this.root = this.insertRecursive(this.root as TreeNode<T>, item);\r\n    }\r\n    private insertRecursive(root: TreeNode<T>, item: T): TreeNode<T> {\r\n        if (root == null) return new TreeNode<T>(item);\r\n        if (this.comparator(item, root.getData()) < 0) {\r\n            root.setLeft(this.insertRecursive(root.getLeft() as TreeNode<T>, item));\r\n        } else if (this.comparator(item, root.getData()) > 0) {\r\n            root.setRight(this.insertRecursive(root.getRight() as TreeNode<T>, item));\r\n        } else {\r\n            return root;\r\n        }\r\n        return root;\r\n    }\r\n    public search(item: T): boolean {\r\n       return this.searchTree(this.root as TreeNode<T>, item);\r\n    }\r\n    private searchTree(root: TreeNode<T>, item: T): boolean {\r\n        if (root == null) return false;\r\n        if (this.comparator(item, root.getData()) === 0) return true;\r\n        if (root.getLeft() != null) {\r\n            if (this.searchTree(root.getLeft() as TreeNode<T>, item)) return true;\r\n        }\r\n        if (root.getRight() != null) {\r\n            if (this.searchTree(root.getRight() as TreeNode<T>, item)) return true;\r\n        }\r\n        return false;\r\n    }\r\n}","export class ArgumentNullException extends Error {\r\n    name = \"ArgumentNullException\";\r\n    message = \"object is null.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","export class ArgumentOutOfRangeException extends Error {\r\n    public name: string = \"ArgumentOutOfRangeException\";\r\n    public message: string = \"arrayIndex is out of range.\";\r\n    public constructor(message: string) {\r\n        super();\r\n        this.message = message;\r\n    }\r\n}","export class ArgumentException extends Error {\r\n    public name = \"ArgumentException\";\r\n    public message = \"Invalid argument.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if(message) {\r\n            this.message = message;\r\n        }\r\n    }\r\n}","export class InvalidOperationException extends Error {\r\n    name = \"InvalidOperationException\";\r\n    message = \"Invalid operation.\"\r\n    public constructor(message?: string) {\r\n        super();\r\n        if (message) this.message = message;\r\n    }\r\n}","import { IList } from \"./IList\";\r\nimport { ArgumentNullException } from \"../exceptions/ArgumentNullException\";\r\nimport { ArgumentOutOfRangeException } from \"../exceptions/ArgumentOutOfRangeException\";\r\nimport { ArgumentException } from \"../exceptions/ArgumentException\";\r\nimport { InvalidOperationException } from \"../exceptions/InvalidOperationException\";\r\nimport { IQueue } from \"../queue/IQueue\";\r\nimport { IDeque } from \"../queue/IDeque\";\r\nimport { AbstractCollection } from \"../core/AbstractCollection\";\r\nimport { ICollection } from \"../core/ICollection\";\r\nimport { Constructor } from \"../core/Constructor\";\r\n\r\nexport class List<T> extends AbstractCollection<T> implements IList<T>, IQueue<T>, IDeque<T> {\r\n    private data: T[] = [];\r\n    public constructor(data?: T[]) {\r\n        super();\r\n        if(data) {\r\n            this.data = [...data];\r\n        }\r\n    }\r\n    public add(item: T): boolean {\r\n        this.data.push(item);\r\n        return true;\r\n    }\r\n    public clear() {\r\n        this.data.length = 0;\r\n    }\r\n    public contains(item: T): boolean {\r\n        return  this.indexOf(item) > -1;\r\n    }\r\n    public dequeue(): T {\r\n        if (this.isEmpty()) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        return item;\r\n    }\r\n    public dequeueLast(): T {\r\n        if (this.isEmpty()) {\r\n            throw new InvalidOperationException(\"queue is empty.\");\r\n        }\r\n        const item = this.data[this.data.length - 1];\r\n        this.data.splice(this.data.length-1, 1);\r\n        return item;\r\n    }\r\n    public enqueue(item: T): void {\r\n        this.add(item);\r\n    }\r\n    public enqueueFirst(item: T): void {\r\n        this.insert(0, item);\r\n    }\r\n    public exists(predicate: (item: T) => boolean): boolean {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        return this.data.some(predicate);\r\n    }\r\n    public find(predicate: (item: T) => boolean): T|null {\r\n        const item = this.data.find(predicate);\r\n        return item || null;\r\n    }\r\n    public findAll(predicate: (item: T) => boolean): List<T> {\r\n        const foundData = this.data.filter(predicate);\r\n        return new List<T>(foundData);\r\n    }\r\n    public findIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        \r\n        startIndex = startIndex || 0;\r\n        count      = count || this.size()-1;\r\n\r\n        if (startIndex! < 0 || startIndex >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.size()) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        \r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex; ix < startIndex+count; ++ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public findLast(predicate: (item: T) => boolean): T {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        let found = false;\r\n        let foundItem: T = null;\r\n        for (let ix = this.data.length - 1; ix >= 0; --ix) {\r\n            const elem = this.data[ix];\r\n            found = predicate(elem);\r\n            if (found) {\r\n                foundItem = elem;\r\n                break;\r\n            }\r\n        }\r\n        return foundItem;\r\n    }\r\n    public findLastIndex(predicate: (item: T) => boolean, startIndex?: number, count?: number): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        if (startIndex < 0 || startIndex >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex is not a valid index.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (startIndex+count > this.size()) {\r\n            throw new ArgumentOutOfRangeException(\"startIndex and count do not specify a valid section in the list.\");\r\n        }\r\n        startIndex = startIndex || 0;\r\n        count      = count || this.size();\r\n        let found  = false;\r\n        let foundIndex = -1;\r\n        for (let ix = startIndex+count-1; ix >= startIndex; --ix) {\r\n            found = predicate(this.data[ix]);\r\n            if (found) {\r\n                foundIndex = ix;\r\n                break;\r\n            }\r\n        }\r\n        return foundIndex;\r\n    }\r\n    public forEach(action: (item: T) => void): void {\r\n        if (!action) {\r\n            throw new ArgumentNullException(\"action is null.\");\r\n        }\r\n        this.data.forEach(d => d ? action(d) : void 0);\r\n    }\r\n    public get(index: number): T {\r\n        if (index == null) {\r\n            throw new ArgumentNullException(\"index is null.\");\r\n        }\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.size()}.`);\r\n        }\r\n        return this.data[index];\r\n    }\r\n    public indexOf(item: T): number {\r\n        return this.data.findIndex(d => d === item);\r\n    }\r\n    public insert(index: number, item: T) {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index !== 0 && index >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.size()}.`);\r\n        }\r\n        this.data.splice(index, 0, item);\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.data.length === 0;\r\n    }\r\n    public lastIndexOf(item: T): number {\r\n        return this.data.lastIndexOf(item);\r\n    }\r\n    public peek(): T {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        return this.get(0);\r\n    }\r\n    public peekLast(): T {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        return this.get(this.size() - 1);\r\n    }\r\n    public poll(): T {\r\n        if (this.isEmpty()) {\r\n            return null;\r\n        }\r\n        const item = this.data[0];\r\n        this.data.splice(0, 1);\r\n        return item;\r\n    }\r\n    public pollLast(): T {\r\n        if (this.isEmpty()) return null;\r\n        const item = this.data[this.size() - 1];\r\n        this.data.splice(this.size() - 1, 1);\r\n        return item;\r\n    }\r\n    public remove(item: T): boolean {\r\n        const index = this.findIndex(d => d === item);\r\n        if (index === -1) return false;\r\n        this.removeAt(index);\r\n        return true;\r\n    }\r\n    public removeAll(predicate: (value: T) => boolean): number {\r\n        if (!predicate) {\r\n            throw new ArgumentNullException(\"predicate is null.\");\r\n        }\r\n        const preCount = this.data.length;\r\n        this.data = this.data.filter(d => !predicate(d));\r\n        return preCount - this.data.length;\r\n    }\r\n    public removeAt(index: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.size()}.`);\r\n        }\r\n        this.data.splice(index, 1);\r\n    }\r\n    public removeRange(index: number, count: number): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (count < 0) {\r\n            throw new ArgumentOutOfRangeException(\"count is less than 0.\");\r\n        }\r\n        if (index+count > this.size()) {\r\n            throw new ArgumentException(\"index and count do not denote a valid range of elements in the list.\");\r\n        }\r\n        let removedCount = 0;\r\n        while(removedCount < count) {\r\n            this.removeAt(index);\r\n            removedCount++;\r\n        }\r\n    }\r\n    public reverse(): void {\r\n        this.data.reverse();\r\n    }\r\n    public set(index: number, item: T): void {\r\n        if (index < 0) {\r\n            throw new ArgumentOutOfRangeException(\"index is less than 0.\");\r\n        }\r\n        if (index >= this.size()) {\r\n            throw new ArgumentOutOfRangeException(`index is greater than or equal to ${this.size()}.`);\r\n        }\r\n        this.data[index] = item;\r\n    }\r\n    public size(): number {\r\n        return this.data.length;\r\n    }\r\n    public sort(comparer?: (e1: T, e2: T) => number): void {\r\n        if (!comparer) {\r\n            comparer = (e1: T, e2: T) => e1 > e2 ? 1 : -1;\r\n        }\r\n        this.data.sort(comparer);\r\n    }\r\n    public toArray(): T[] {\r\n        return [...this.data];\r\n    }\r\n    public transform<U extends ICollection<T>>(Collection: Constructor<U>, comparator?: (v1: T, v2: T) => number): U {\r\n        const collection = new Collection(comparator);\r\n        this.data.forEach(d => collection.add(d));\r\n        return collection;\r\n    }\r\n}\r\n","import { ISet } from \"./ISet\";\r\nimport { BinarySearchTree } from \"../tree/BinarySearchTree\";\r\n\r\nexport class TreeSet<T> implements ISet<T> {\r\n    private comparator: (v1: T, v2: T) => number = (v1: T|any, v2: T|any) => v1-v2;\r\n    private tree: BinarySearchTree<T>;\r\n    public constructor(comparator?: (v1: T, v2: T) => number) {\r\n        if (comparator) this.comparator = comparator;\r\n        this.tree = new BinarySearchTree<T>(this.comparator);\r\n    }\r\n    public add(item: T): boolean {\r\n        if (this.tree.search(item)) return false;\r\n        this.tree.insert(item);\r\n        return true;\r\n    }\r\n    public clear(): void {\r\n        this.tree.clear();\r\n    }\r\n    public contains(item: T): boolean {\r\n        return this.tree.contains(item);\r\n    }\r\n    public isEmpty(): boolean {\r\n        return this.tree.isEmpty();\r\n    }\r\n    public remove(item: T): boolean {\r\n        return this.tree.remove(item);\r\n    }\r\n    public size(): number {\r\n        return this.tree.size();\r\n    }\r\n    public toArray(): T[] {\r\n        return this.tree.toArray();\r\n    }\r\n}"],"names":["AbstractCollection","transform","Collection","comparator","collection","toArray","forEach","item","add","AbstractTree","constructor","clear","root","contains","this","containsRecursive","getData","getLeft","getRight","countTreeNodes","find","predicate","findRecursive","foundItem","action","forEachRecursive","getRootData","isEmpty","remove","delete","size","target","toArrayRecursive","push","toInorderArray","toPostorderArray","toPreorderArray","c","transformRecursive","traverseAndMapToArray","mapper","direction","array","map","v","TreeNode","data","left","right","setData","setLeft","node","setRight","RedBlackNode","parent","color","RED","getColor","getParent","getSibling","isOnLeft","getUncle","hasRedChild","moveDown","p","setParent","setColor","BinarySearchTree","search","insert","searchNode","deleteNode","u","findReplaceItem","bothBlack","BLACK","swapValues","fixDoubleBlack","getSuccessor","sibling","rightRotate","leftRotate","fixDoubleRed","grandParent","uncle","swapColors","temp","BinaryTree","deleteRecursive","smallestValue","findSmallestValue","insertRecursive","searchTree","ArgumentNullException","message","Error","ArgumentOutOfRangeException","ArgumentException","InvalidOperationException","List","length","indexOf","dequeue","splice","dequeueLast","enqueue","enqueueFirst","exists","some","findAll","filter","findIndex","startIndex","count","foundIndex","ix","findLast","elem","findLastIndex","d","get","index","lastIndexOf","peek","peekLast","poll","pollLast","removeAt","removeAll","preCount","removeRange","removedCount","reverse","set","sort","comparer","e1","e2","TreeSet","v1","v2","tree"],"mappings":"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"}